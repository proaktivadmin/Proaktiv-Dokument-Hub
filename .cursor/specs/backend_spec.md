# BACKEND SPECIFICATION - V2.7 Document Hub

**Generated by:** Systems Architect Agent  
**Date:** 2026-01-16  
**Phase:** 2.7 (Template Content Editing & Settings Persistence)

---

## EXECUTIVE SUMMARY

This specification extends the V2.6 backend to support:
1. **Template Content Editing** - Save edited HTML content back to storage
2. **Template Settings Persistence** - Save Vitec metadata and layout settings
3. **Thumbnail Generation** - Static thumbnail generation for faster card loading
4. **Enhanced Template Versioning** - Wire up existing TemplateVersion model

### Current State (V2.6)
- ✅ 43 templates in Azure Storage with real URLs
- ✅ MergeField, CodePattern, LayoutPartial services implemented
- ✅ TemplateAnalyzerService extracts merge fields from content
- ✅ Template model has `content` field for HTML storage
- ✅ TemplateVersion model exists but not wired up

### Target State (V2.7)
- PUT endpoint to save template HTML content
- PUT endpoint to save template settings (margins, header/footer, metadata)
- Automatic versioning when content is modified
- Static thumbnail generation pipeline
- Dashboard stats endpoint

---

## T1: NEW API ENDPOINTS

### 1.1 Save Template Content

**Endpoint:** `PUT /api/templates/{template_id}/content`

**Purpose:** Save edited HTML content and trigger versioning.

```yaml
path: /api/templates/{template_id}/content
method: PUT
summary: Save template HTML content
description: |
  Updates the template's HTML content. Creates a version snapshot
  before saving if the content has changed. Re-scans for merge fields
  and updates the template's vitec_merge_fields array.
  
requestBody:
  required: true
  content:
    application/json:
      schema:
        type: object
        required:
          - content
        properties:
          content:
            type: string
            description: The new HTML content
          change_notes:
            type: string
            description: Optional notes about the change
            maxLength: 500
          auto_sanitize:
            type: boolean
            default: true
            description: Whether to sanitize the HTML for Vitec compatibility

responses:
  200:
    description: Content saved successfully
    content:
      application/json:
        schema:
          type: object
          properties:
            id:
              type: string
              format: uuid
            version:
              type: integer
              description: New version number
            content_hash:
              type: string
              description: SHA256 hash of new content
            merge_fields_detected:
              type: integer
              description: Number of merge fields found
            previous_version_id:
              type: string
              format: uuid
              nullable: true
              description: ID of the version snapshot (if created)
  400:
    description: Invalid content or not an HTML template
  404:
    description: Template not found
```

### 1.2 Save Template Settings

**Endpoint:** `PUT /api/templates/{template_id}/settings`

**Purpose:** Update template metadata and layout settings.

```yaml
path: /api/templates/{template_id}/settings
method: PUT
summary: Update template settings
description: |
  Updates the template's Vitec metadata fields including channel,
  receiver, phases, margins, and header/footer references.
  Does NOT create a version (settings changes don't require versioning).

requestBody:
  required: true
  content:
    application/json:
      schema:
        $ref: '#/components/schemas/TemplateSettingsUpdate'

responses:
  200:
    description: Settings saved successfully
    content:
      application/json:
        schema:
          $ref: '#/components/schemas/TemplateSettingsResponse'
  400:
    description: Invalid settings
  404:
    description: Template not found
```

### 1.3 Dashboard Stats

**Endpoint:** `GET /api/dashboard/stats`

**Purpose:** Return statistics for the dashboard.

```yaml
path: /api/dashboard/stats
method: GET
summary: Get dashboard statistics
description: Returns template counts and recent activity stats.

responses:
  200:
    content:
      application/json:
        schema:
          type: object
          properties:
            total:
              type: integer
              description: Total number of templates
            published:
              type: integer
              description: Number of published templates
            draft:
              type: integer
              description: Number of draft templates
            archived:
              type: integer
              description: Number of archived templates
            downloads:
              type: integer
              description: Total downloads (from audit log)
            recent_uploads:
              type: array
              items:
                type: object
                properties:
                  id:
                    type: string
                  title:
                    type: string
                  created_at:
                    type: string
                    format: date-time
              maxItems: 5
```

### 1.4 Generate Thumbnail

**Endpoint:** `POST /api/templates/{template_id}/thumbnail`

**Purpose:** Generate and store a static thumbnail for a template.

```yaml
path: /api/templates/{template_id}/thumbnail
method: POST
summary: Generate template thumbnail
description: |
  Renders the template HTML as an image and stores it in Azure Blob Storage.
  Updates the template's preview_thumbnail_url field.

responses:
  200:
    content:
      application/json:
        schema:
          type: object
          properties:
            thumbnail_url:
              type: string
              description: URL to the generated thumbnail
            width:
              type: integer
            height:
              type: integer
  400:
    description: Not an HTML template
  404:
    description: Template not found
  501:
    description: Thumbnail generation not available (Playwright not installed)
```

---

## T2: PYDANTIC SCHEMAS

### File: `backend/app/schemas/template_settings.py`

```python
"""
Pydantic schemas for Template Settings operations.
"""

from pydantic import BaseModel, Field, ConfigDict
from typing import Optional, List, Literal
from uuid import UUID
from decimal import Decimal
from datetime import datetime


class TemplateContentUpdate(BaseModel):
    """Schema for updating template HTML content."""
    content: str = Field(..., min_length=1, description="HTML content")
    change_notes: Optional[str] = Field(None, max_length=500, description="Notes about the change")
    auto_sanitize: bool = Field(True, description="Sanitize HTML for Vitec compatibility")


class TemplateContentResponse(BaseModel):
    """Schema for template content update response."""
    id: UUID
    version: int
    content_hash: str
    merge_fields_detected: int
    previous_version_id: Optional[UUID] = None


class TemplateSettingsUpdate(BaseModel):
    """
    Schema for updating template Vitec settings.
    All fields are optional for partial updates.
    """
    # Channel and Type
    channel: Optional[Literal['pdf', 'email', 'sms', 'pdf_email']] = Field(
        None, description="Template channel type"
    )
    template_type: Optional[Literal['Objekt/Kontakt', 'System']] = Field(
        None, description="Template type"
    )
    
    # Receiver
    receiver_type: Optional[Literal['Egne/kundetilpasset', 'Systemstandard']] = Field(
        None, description="Receiver type"
    )
    receiver: Optional[Literal['Selger', 'Kjøper', 'Megler', 'Bank', 'Forretningsfører']] = Field(
        None, description="Primary receiver"
    )
    extra_receivers: Optional[List[str]] = Field(
        None, description="Additional receivers"
    )
    
    # Filtering/Categorization
    phases: Optional[List[Literal['Oppdrag', 'Markedsføring', 'Visning', 'Budrunde', 'Kontrakt', 'Oppgjør']]] = Field(
        None, description="Applicable phases"
    )
    assignment_types: Optional[List[str]] = Field(
        None, description="Assignment types"
    )
    ownership_types: Optional[List[Literal['Bolig', 'Aksje', 'Tomt', 'Næring', 'Hytte']]] = Field(
        None, description="Ownership types"
    )
    departments: Optional[List[str]] = Field(
        None, description="Departments"
    )
    
    # Email
    email_subject: Optional[str] = Field(
        None, max_length=500, description="Email subject line (can include merge fields)"
    )
    
    # Layout
    header_template_id: Optional[UUID] = Field(
        None, description="Header layout partial ID"
    )
    footer_template_id: Optional[UUID] = Field(
        None, description="Footer layout partial ID"
    )
    
    # Margins (in cm)
    margin_top: Optional[Decimal] = Field(
        None, ge=0, le=10, description="Top margin in cm"
    )
    margin_bottom: Optional[Decimal] = Field(
        None, ge=0, le=10, description="Bottom margin in cm"
    )
    margin_left: Optional[Decimal] = Field(
        None, ge=0, le=10, description="Left margin in cm"
    )
    margin_right: Optional[Decimal] = Field(
        None, ge=0, le=10, description="Right margin in cm"
    )


class TemplateSettingsResponse(BaseModel):
    """Schema for template settings response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    title: str
    channel: Optional[str] = None
    template_type: Optional[str] = None
    receiver_type: Optional[str] = None
    receiver: Optional[str] = None
    extra_receivers: List[str] = []
    phases: List[str] = []
    assignment_types: List[str] = []
    ownership_types: List[str] = []
    departments: List[str] = []
    email_subject: Optional[str] = None
    header_template_id: Optional[UUID] = None
    footer_template_id: Optional[UUID] = None
    margin_top: Optional[Decimal] = None
    margin_bottom: Optional[Decimal] = None
    margin_left: Optional[Decimal] = None
    margin_right: Optional[Decimal] = None
    updated_at: datetime


class DashboardStatsResponse(BaseModel):
    """Schema for dashboard statistics."""
    total: int
    published: int
    draft: int
    archived: int
    downloads: int
    recent_uploads: List[dict]
```

---

## T3: DATABASE MIGRATION

### Migration: Add Missing Vitec Metadata Columns

The template model needs additional columns for Vitec parity. Check if these columns exist before adding.

```sql
-- Migration: 20260116_add_vitec_metadata_columns.py
-- Description: Add Vitec-compatible metadata fields to templates table

-- Check and add columns if they don't exist
DO $$
BEGIN
    -- Channel
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'templates' AND column_name = 'channel') THEN
        ALTER TABLE templates ADD COLUMN channel VARCHAR(20) DEFAULT 'pdf_email';
    END IF;
    
    -- Template type
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'templates' AND column_name = 'template_type') THEN
        ALTER TABLE templates ADD COLUMN template_type VARCHAR(50) DEFAULT 'Objekt/Kontakt';
    END IF;
    
    -- Receiver type
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'templates' AND column_name = 'receiver_type') THEN
        ALTER TABLE templates ADD COLUMN receiver_type VARCHAR(50);
    END IF;
    
    -- Receiver
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'templates' AND column_name = 'receiver') THEN
        ALTER TABLE templates ADD COLUMN receiver VARCHAR(100);
    END IF;
    
    -- Extra receivers (JSONB array)
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'templates' AND column_name = 'extra_receivers') THEN
        ALTER TABLE templates ADD COLUMN extra_receivers JSONB DEFAULT '[]';
    END IF;
    
    -- Phases (JSONB array)
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'templates' AND column_name = 'phases') THEN
        ALTER TABLE templates ADD COLUMN phases JSONB DEFAULT '[]';
    END IF;
    
    -- Assignment types (JSONB array)
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'templates' AND column_name = 'assignment_types') THEN
        ALTER TABLE templates ADD COLUMN assignment_types JSONB DEFAULT '[]';
    END IF;
    
    -- Ownership types (JSONB array)
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'templates' AND column_name = 'ownership_types') THEN
        ALTER TABLE templates ADD COLUMN ownership_types JSONB DEFAULT '[]';
    END IF;
    
    -- Departments (JSONB array)
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'templates' AND column_name = 'departments') THEN
        ALTER TABLE templates ADD COLUMN departments JSONB DEFAULT '[]';
    END IF;
    
    -- Email subject
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'templates' AND column_name = 'email_subject') THEN
        ALTER TABLE templates ADD COLUMN email_subject VARCHAR(500);
    END IF;
    
    -- Header template ID
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'templates' AND column_name = 'header_template_id') THEN
        ALTER TABLE templates ADD COLUMN header_template_id UUID;
    END IF;
    
    -- Footer template ID
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'templates' AND column_name = 'footer_template_id') THEN
        ALTER TABLE templates ADD COLUMN footer_template_id UUID;
    END IF;
    
    -- Margins
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'templates' AND column_name = 'margin_top') THEN
        ALTER TABLE templates ADD COLUMN margin_top DECIMAL(4,2) DEFAULT 1.5;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'templates' AND column_name = 'margin_bottom') THEN
        ALTER TABLE templates ADD COLUMN margin_bottom DECIMAL(4,2) DEFAULT 1.0;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'templates' AND column_name = 'margin_left') THEN
        ALTER TABLE templates ADD COLUMN margin_left DECIMAL(4,2) DEFAULT 1.0;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'templates' AND column_name = 'margin_right') THEN
        ALTER TABLE templates ADD COLUMN margin_right DECIMAL(4,2) DEFAULT 1.2;
    END IF;
    
    -- Preview thumbnail URL
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'templates' AND column_name = 'preview_thumbnail_url') THEN
        ALTER TABLE templates ADD COLUMN preview_thumbnail_url TEXT;
    END IF;
END $$;

-- Add foreign key constraints if layout_partials table exists
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'layout_partials') THEN
        IF NOT EXISTS (SELECT 1 FROM information_schema.table_constraints 
                       WHERE constraint_name = 'fk_templates_header_template_id') THEN
            ALTER TABLE templates
                ADD CONSTRAINT fk_templates_header_template_id 
                FOREIGN KEY (header_template_id) REFERENCES layout_partials(id) ON DELETE SET NULL;
        END IF;
        
        IF NOT EXISTS (SELECT 1 FROM information_schema.table_constraints 
                       WHERE constraint_name = 'fk_templates_footer_template_id') THEN
            ALTER TABLE templates
                ADD CONSTRAINT fk_templates_footer_template_id 
                FOREIGN KEY (footer_template_id) REFERENCES layout_partials(id) ON DELETE SET NULL;
        END IF;
    END IF;
END $$;
```

---

## T4: SERVICE INTERFACES

### File: `backend/app/services/template_content_service.py`

```python
"""
Template Content Service - Handles saving and versioning template content.
"""

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from typing import Optional
from uuid import UUID
import hashlib
import logging

from app.models.template import Template, TemplateVersion
from app.services.template_analyzer_service import TemplateAnalyzerService
from app.services.sanitizer_service import get_sanitizer_service

logger = logging.getLogger(__name__)


class TemplateContentService:
    """
    Service for template content operations including versioning.
    """
    
    @staticmethod
    async def save_content(
        db: AsyncSession,
        template_id: UUID,
        *,
        content: str,
        updated_by: str,
        change_notes: Optional[str] = None,
        auto_sanitize: bool = True
    ) -> dict:
        """
        Save template HTML content with automatic versioning.
        
        Args:
            db: Database session
            template_id: Template UUID
            content: New HTML content
            updated_by: User email
            change_notes: Optional notes about the change
            auto_sanitize: Whether to sanitize the HTML
            
        Returns:
            Dict containing:
            - id: Template UUID
            - version: New version number
            - content_hash: SHA256 hash of content
            - merge_fields_detected: Count of merge fields
            - previous_version_id: UUID of version snapshot (if created)
            
        Raises:
            HTTPException: If template not found or not HTML
        """
        pass
    
    @staticmethod
    async def create_version_snapshot(
        db: AsyncSession,
        template: Template,
        *,
        created_by: str,
        change_notes: Optional[str] = None
    ) -> TemplateVersion:
        """
        Create a version snapshot of the current template state.
        
        Args:
            db: Database session
            template: Template to snapshot
            created_by: User email
            change_notes: Optional notes
            
        Returns:
            Created TemplateVersion
        """
        pass
    
    @staticmethod
    def compute_content_hash(content: str) -> str:
        """
        Compute SHA256 hash of content.
        
        Args:
            content: String content
            
        Returns:
            Hex-encoded SHA256 hash
        """
        return hashlib.sha256(content.encode('utf-8')).hexdigest()
```

### File: `backend/app/services/template_settings_service.py`

```python
"""
Template Settings Service - Handles template metadata and settings.
"""

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from typing import Optional, List
from uuid import UUID
from decimal import Decimal
import logging

from app.models.template import Template
from app.models.layout_partial import LayoutPartial

logger = logging.getLogger(__name__)


class TemplateSettingsService:
    """
    Service for template settings and metadata operations.
    """
    
    @staticmethod
    async def update_settings(
        db: AsyncSession,
        template_id: UUID,
        *,
        updated_by: str,
        channel: Optional[str] = None,
        template_type: Optional[str] = None,
        receiver_type: Optional[str] = None,
        receiver: Optional[str] = None,
        extra_receivers: Optional[List[str]] = None,
        phases: Optional[List[str]] = None,
        assignment_types: Optional[List[str]] = None,
        ownership_types: Optional[List[str]] = None,
        departments: Optional[List[str]] = None,
        email_subject: Optional[str] = None,
        header_template_id: Optional[UUID] = None,
        footer_template_id: Optional[UUID] = None,
        margin_top: Optional[Decimal] = None,
        margin_bottom: Optional[Decimal] = None,
        margin_left: Optional[Decimal] = None,
        margin_right: Optional[Decimal] = None
    ) -> Template:
        """
        Update template settings and metadata.
        
        Args:
            db: Database session
            template_id: Template UUID
            updated_by: User email
            **settings: Settings to update
            
        Returns:
            Updated template
            
        Raises:
            HTTPException: If template not found or invalid settings
        """
        pass
    
    @staticmethod
    async def get_settings(
        db: AsyncSession,
        template_id: UUID
    ) -> dict:
        """
        Get template settings as a dictionary.
        
        Args:
            db: Database session
            template_id: Template UUID
            
        Returns:
            Dict of settings
            
        Raises:
            HTTPException: If template not found
        """
        pass
    
    @staticmethod
    async def validate_layout_partial(
        db: AsyncSession,
        partial_id: UUID,
        expected_type: str
    ) -> bool:
        """
        Validate that a layout partial exists and is of the expected type.
        
        Args:
            db: Database session
            partial_id: LayoutPartial UUID
            expected_type: 'header' or 'footer'
            
        Returns:
            True if valid
            
        Raises:
            HTTPException: If partial not found or wrong type
        """
        pass
```

### File: `backend/app/services/dashboard_service.py`

```python
"""
Dashboard Service - Statistics and analytics.
"""

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from typing import List
import logging

from app.models.template import Template
from app.models.audit_log import AuditLog

logger = logging.getLogger(__name__)


class DashboardService:
    """
    Service for dashboard statistics and analytics.
    """
    
    @staticmethod
    async def get_stats(db: AsyncSession) -> dict:
        """
        Get dashboard statistics.
        
        Returns:
            Dict containing:
            - total: Total template count
            - published: Published template count
            - draft: Draft template count
            - archived: Archived template count
            - downloads: Total download count from audit log
            - recent_uploads: List of 5 most recent templates
        """
        pass
    
    @staticmethod
    async def get_recent_uploads(
        db: AsyncSession,
        limit: int = 5
    ) -> List[dict]:
        """
        Get most recently uploaded templates.
        
        Args:
            db: Database session
            limit: Maximum number of results
            
        Returns:
            List of template summary dicts
        """
        pass
    
    @staticmethod
    async def get_download_count(db: AsyncSession) -> int:
        """
        Get total download count from audit log.
        
        Args:
            db: Database session
            
        Returns:
            Total download count
        """
        pass
```

### File: `backend/app/services/thumbnail_service.py`

```python
"""
Thumbnail Service - Generate static thumbnails for templates.
"""

from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional
from uuid import UUID
import logging

from app.models.template import Template
from app.services.azure_storage_service import get_azure_storage_service

logger = logging.getLogger(__name__)


class ThumbnailService:
    """
    Service for generating and storing template thumbnails.
    
    Uses Playwright to render HTML templates as images.
    Falls back gracefully if Playwright is not available.
    """
    
    THUMBNAIL_WIDTH = 210  # A4 width at ~72 DPI
    THUMBNAIL_HEIGHT = 297  # A4 height at ~72 DPI
    THUMBNAIL_SCALE = 0.5  # Scale factor for smaller file size
    
    @classmethod
    async def generate_thumbnail(
        cls,
        db: AsyncSession,
        template_id: UUID
    ) -> dict:
        """
        Generate a thumbnail for a template.
        
        Args:
            db: Database session
            template_id: Template UUID
            
        Returns:
            Dict containing:
            - thumbnail_url: URL to the generated thumbnail
            - width: Thumbnail width in pixels
            - height: Thumbnail height in pixels
            
        Raises:
            HTTPException: If template not found or generation fails
        """
        pass
    
    @classmethod
    async def render_html_to_image(
        cls,
        html_content: str,
        *,
        width: int = 210,
        height: int = 297,
        scale: float = 0.5
    ) -> bytes:
        """
        Render HTML content to a PNG image.
        
        Args:
            html_content: HTML to render
            width: Viewport width
            height: Viewport height
            scale: Scale factor
            
        Returns:
            PNG image bytes
            
        Raises:
            ImportError: If Playwright is not installed
        """
        pass
    
    @classmethod
    def is_available(cls) -> bool:
        """
        Check if thumbnail generation is available.
        
        Returns:
            True if Playwright is installed and configured
        """
        try:
            from playwright.async_api import async_playwright
            return True
        except ImportError:
            return False
```

---

## T5: ROUTER IMPLEMENTATIONS

### File: `backend/app/routers/dashboard.py`

```python
"""
Dashboard API Routes
"""

from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession

from app.database import get_db
from app.services.dashboard_service import DashboardService
from app.schemas.template_settings import DashboardStatsResponse

router = APIRouter(prefix="/dashboard", tags=["Dashboard"])


@router.get("/stats", response_model=DashboardStatsResponse)
async def get_dashboard_stats(
    db: AsyncSession = Depends(get_db)
):
    """Get dashboard statistics."""
    stats = await DashboardService.get_stats(db)
    return DashboardStatsResponse(**stats)
```

### Update: `backend/app/routers/templates.py`

Add these endpoints to the existing templates router:

```python
# Add to existing imports
from app.services.template_content_service import TemplateContentService
from app.services.template_settings_service import TemplateSettingsService
from app.services.thumbnail_service import ThumbnailService
from app.schemas.template_settings import (
    TemplateContentUpdate,
    TemplateContentResponse,
    TemplateSettingsUpdate,
    TemplateSettingsResponse
)


@router.put("/{template_id}/content", response_model=TemplateContentResponse)
async def save_template_content(
    template_id: UUID,
    body: TemplateContentUpdate,
    db: AsyncSession = Depends(get_db),
    user: dict = Depends(get_current_user)
):
    """
    Save template HTML content.
    
    Creates a version snapshot before saving if content has changed.
    Re-scans for merge fields and updates the template.
    """
    result = await TemplateContentService.save_content(
        db,
        template_id,
        content=body.content,
        updated_by=user["email"],
        change_notes=body.change_notes,
        auto_sanitize=body.auto_sanitize
    )
    
    # Audit log
    await AuditService.log(
        db,
        entity_type="template",
        entity_id=template_id,
        action="content_updated",
        user_email=user["email"],
        details={"version": result["version"]}
    )
    
    return TemplateContentResponse(**result)


@router.put("/{template_id}/settings", response_model=TemplateSettingsResponse)
async def update_template_settings(
    template_id: UUID,
    body: TemplateSettingsUpdate,
    db: AsyncSession = Depends(get_db),
    user: dict = Depends(get_current_user)
):
    """Update template Vitec metadata settings."""
    template = await TemplateSettingsService.update_settings(
        db,
        template_id,
        updated_by=user["email"],
        **body.model_dump(exclude_unset=True)
    )
    
    # Audit log
    await AuditService.log(
        db,
        entity_type="template",
        entity_id=template_id,
        action="settings_updated",
        user_email=user["email"],
        details=body.model_dump(exclude_unset=True)
    )
    
    return TemplateSettingsResponse.model_validate(template)


@router.get("/{template_id}/settings", response_model=TemplateSettingsResponse)
async def get_template_settings(
    template_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Get template settings."""
    settings = await TemplateSettingsService.get_settings(db, template_id)
    return TemplateSettingsResponse(**settings)


@router.post("/{template_id}/thumbnail")
async def generate_thumbnail(
    template_id: UUID,
    db: AsyncSession = Depends(get_db),
    user: dict = Depends(get_current_user)
):
    """
    Generate a static thumbnail for a template.
    
    Requires Playwright to be installed. Returns 501 if not available.
    """
    if not ThumbnailService.is_available():
        raise HTTPException(
            status_code=501,
            detail="Thumbnail generation not available. Playwright is not installed."
        )
    
    result = await ThumbnailService.generate_thumbnail(db, template_id)
    
    # Audit log
    await AuditService.log(
        db,
        entity_type="template",
        entity_id=template_id,
        action="thumbnail_generated",
        user_email=user["email"]
    )
    
    return result
```

---

## T6: MODEL UPDATES

### Update: `backend/app/models/template.py`

Add the new Vitec metadata fields to the Template model:

```python
# Add these fields after the existing fields in the Template class

# Vitec Metadata Fields
channel: Mapped[str] = mapped_column(String(20), default="pdf_email")
template_type: Mapped[str] = mapped_column(String(50), default="Objekt/Kontakt")
receiver_type: Mapped[Optional[str]] = mapped_column(String(50), nullable=True)
receiver: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)
extra_receivers: Mapped[Optional[List[str]]] = mapped_column(
    JSONB,
    nullable=True,
    default=list
)
phases: Mapped[Optional[List[str]]] = mapped_column(
    JSONB,
    nullable=True,
    default=list
)
assignment_types: Mapped[Optional[List[str]]] = mapped_column(
    JSONB,
    nullable=True,
    default=list
)
ownership_types: Mapped[Optional[List[str]]] = mapped_column(
    JSONB,
    nullable=True,
    default=list
)
departments: Mapped[Optional[List[str]]] = mapped_column(
    JSONB,
    nullable=True,
    default=list
)
email_subject: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)

# Layout References
header_template_id: Mapped[Optional[uuid.UUID]] = mapped_column(
    UUID(as_uuid=True),
    ForeignKey("layout_partials.id", ondelete="SET NULL"),
    nullable=True
)
footer_template_id: Mapped[Optional[uuid.UUID]] = mapped_column(
    UUID(as_uuid=True),
    ForeignKey("layout_partials.id", ondelete="SET NULL"),
    nullable=True
)

# Margins (in cm)
margin_top: Mapped[Optional[Decimal]] = mapped_column(
    Numeric(4, 2),
    default=Decimal("1.5")
)
margin_bottom: Mapped[Optional[Decimal]] = mapped_column(
    Numeric(4, 2),
    default=Decimal("1.0")
)
margin_left: Mapped[Optional[Decimal]] = mapped_column(
    Numeric(4, 2),
    default=Decimal("1.0")
)
margin_right: Mapped[Optional[Decimal]] = mapped_column(
    Numeric(4, 2),
    default=Decimal("1.2")
)

# Thumbnail
preview_thumbnail_url: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
```

---

## T7: FILE STRUCTURE ADDITIONS

```
backend/
├── app/
│   ├── schemas/
│   │   └── template_settings.py     # NEW - Content and settings schemas
│   ├── services/
│   │   ├── template_content_service.py   # NEW - Content saving with versioning
│   │   ├── template_settings_service.py  # NEW - Settings management
│   │   ├── dashboard_service.py          # NEW - Dashboard stats
│   │   └── thumbnail_service.py          # NEW - Thumbnail generation
│   └── routers/
│       └── dashboard.py                  # NEW - Dashboard API routes
└── alembic/
    └── versions/
        └── 20260116_add_vitec_metadata_columns.py  # NEW - Migration
```

---

## T8: IMPLEMENTATION ORDER

### Phase 1: Foundation (Priority: P0)
1. Create `template_settings.py` schemas
2. Update Template model with new fields
3. Create Alembic migration
4. Run migration to add columns

### Phase 2: Dashboard (Priority: P0)
5. Create `dashboard_service.py`
6. Create `dashboard.py` router
7. Register dashboard router in `main.py`
8. Test: `GET /api/dashboard/stats` returns counts

### Phase 3: Content Editing (Priority: P0)
9. Create `template_content_service.py`
10. Add `PUT /api/templates/{id}/content` endpoint
11. Test: Content saves and version is created

### Phase 4: Settings (Priority: P1)
12. Create `template_settings_service.py`
13. Add `PUT /api/templates/{id}/settings` endpoint
14. Add `GET /api/templates/{id}/settings` endpoint
15. Test: Settings save correctly

### Phase 5: Thumbnails (Priority: P2)
16. Create `thumbnail_service.py`
17. Add `POST /api/templates/{id}/thumbnail` endpoint
18. Test: Thumbnail generates (if Playwright installed)

---

## T9: TEST CRITERIA

- [ ] `GET /api/dashboard/stats` returns `{total, published, draft, archived, downloads, recent_uploads}`
- [ ] `PUT /api/templates/{id}/content` saves content and increments version
- [ ] Content save creates TemplateVersion record
- [ ] Content save re-scans merge fields
- [ ] `PUT /api/templates/{id}/settings` updates all metadata fields
- [ ] Settings update validates header_template_id references header type
- [ ] Settings update validates footer_template_id references footer type
- [ ] `GET /api/templates/{id}/settings` returns current settings
- [ ] `POST /api/templates/{id}/thumbnail` returns 501 if Playwright not installed
- [ ] Audit log records all operations

---

## HANDOFF TO FRONTEND ARCHITECT

The frontend needs to:
1. Call `PUT /api/templates/{id}/content` when user saves in code editor
2. Call `PUT /api/templates/{id}/settings` when user changes settings in Settings tab
3. Update dashboard to use `GET /api/dashboard/stats`
4. Optionally trigger thumbnail generation after content save

---

**Next Step:** Invoke **FRONTEND ARCHITECT** agent to create updated `frontend_spec.md`
