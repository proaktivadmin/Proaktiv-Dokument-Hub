# BACKEND SPECIFICATION - V3.2 Document Hub

**Generated by:** Systems Architect Agent  
**Date:** 2026-01-17 (Updated 2026-01-22)  
**Phase:** 3.2 (Stack Upgraded, CI/CD Active)

> **Note:** Stack upgraded on 2026-01-22: SQLAlchemy 2.0.46, Pytest + Pyright + Ruff in CI

---

## EXECUTIVE SUMMARY

This specification documents the current backend state at V2.9 and defines the next phase of implementation. The backend has successfully migrated from Azure to Railway with PostgreSQL and implements most V2 Blueprint features.

### Current State (V2.9) - PRODUCTION LIVE

| Component | Status | Notes |
|-----------|--------|-------|
| PostgreSQL Database | ✅ | Railway managed, 44 templates |
| Template CRUD | ✅ | Full lifecycle with versioning |
| Content Editing API | ✅ | PUT with auto-versioning |
| Settings Persistence API | ✅ | Vitec metadata fields |
| MergeField Service | ✅ | CRUD + auto-discovery |
| CodePattern Service | ✅ | CRUD with usage tracking |
| LayoutPartial Service | ✅ | Headers/footers/signatures |
| Template Analyzer | ✅ | Extract merge fields, conditions, loops |
| Sanitizer Service | ✅ | Vitec Stilark compliance |
| WebDAV Storage | ✅ | Service ready, needs server config |
| Authentication | ✅ | Password + JWT (7-day expiry) |
| Dashboard Stats | ✅ | Template counts + inventory |

### Target State (V3.0)

1. **Merge Field Seeding** - Populate database with known Vitec fields
2. **Enhanced Template Analysis** - Better unknown field categorization
3. **Bulk Operations** - Multi-template actions
4. **Version Restore** - UI to restore previous versions
5. **Inventory Sync** - Track templates vs Vitec registry

---

## CURRENT DATABASE SCHEMA

### Core Tables

```sql
-- Already implemented and migrated to Railway PostgreSQL

CREATE TABLE templates (
    id UUID PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_type VARCHAR(10) NOT NULL,
    file_size_bytes BIGINT NOT NULL,
    azure_blob_url TEXT NOT NULL,  -- Legacy name, now stores Railway/WebDAV URLs
    created_by VARCHAR(255) NOT NULL,
    updated_by VARCHAR(255) NOT NULL,
    description TEXT,
    azure_blob_container VARCHAR(100) DEFAULT 'templates',
    status VARCHAR(20) DEFAULT 'draft',
    version INTEGER DEFAULT 1,
    preview_url TEXT,
    page_count INTEGER,
    language VARCHAR(10) DEFAULT 'nb-NO',
    content TEXT,  -- HTML content for rendering
    vitec_merge_fields JSONB DEFAULT '[]',
    metadata JSONB DEFAULT '{}',
    
    -- Vitec Metadata (V2.7+)
    channel VARCHAR(20) DEFAULT 'pdf_email',
    template_type VARCHAR(50) DEFAULT 'Objekt/Kontakt',
    receiver_type VARCHAR(50),
    receiver VARCHAR(100),
    extra_receivers JSONB DEFAULT '[]',
    phases JSONB DEFAULT '[]',
    assignment_types JSONB DEFAULT '[]',
    ownership_types JSONB DEFAULT '[]',
    departments JSONB DEFAULT '[]',
    email_subject VARCHAR(500),
    header_template_id UUID REFERENCES layout_partials(id) ON DELETE SET NULL,
    footer_template_id UUID REFERENCES layout_partials(id) ON DELETE SET NULL,
    margin_top NUMERIC(4,2) DEFAULT 1.5,
    margin_bottom NUMERIC(4,2) DEFAULT 1.0,
    margin_left NUMERIC(4,2) DEFAULT 1.0,
    margin_right NUMERIC(4,2) DEFAULT 1.2,
    preview_thumbnail_url TEXT,
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    published_at TIMESTAMPTZ
);

CREATE TABLE merge_fields (
    id UUID PRIMARY KEY,
    path VARCHAR(200) UNIQUE NOT NULL,
    category VARCHAR(100) NOT NULL,
    label VARCHAR(200) NOT NULL,
    description TEXT,
    example_value VARCHAR(500),
    data_type VARCHAR(50) DEFAULT 'string',
    is_iterable BOOLEAN DEFAULT FALSE,
    parent_model VARCHAR(100),
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE code_patterns (
    id UUID PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    category VARCHAR(100) NOT NULL,
    description TEXT,
    html_code TEXT NOT NULL,
    variables_used JSONB DEFAULT '[]',
    preview_thumbnail_url TEXT,
    usage_count INTEGER DEFAULT 0,
    created_by VARCHAR(255) NOT NULL,
    updated_by VARCHAR(255) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE layout_partials (
    id UUID PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    type VARCHAR(20) NOT NULL CHECK (type IN ('header', 'footer', 'signature')),
    context VARCHAR(50) DEFAULT 'all' CHECK (context IN ('pdf', 'email', 'sms', 'all')),
    document_type VARCHAR(50),  -- For specialized footers
    html_content TEXT NOT NULL,
    is_default BOOLEAN DEFAULT FALSE,
    created_by VARCHAR(255) NOT NULL,
    updated_by VARCHAR(255) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE template_versions (
    id UUID PRIMARY KEY,
    template_id UUID NOT NULL REFERENCES templates(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    azure_blob_url TEXT NOT NULL,
    file_size_bytes BIGINT NOT NULL,
    created_by VARCHAR(255) NOT NULL,
    change_notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (template_id, version_number)
);

CREATE TABLE categories (
    id UUID PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    description TEXT,
    icon VARCHAR(50),
    sort_order INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE tags (
    id UUID PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    color VARCHAR(7) DEFAULT '#6B7280',
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE audit_logs (
    id UUID PRIMARY KEY,
    entity_type VARCHAR(50) NOT NULL,
    entity_id UUID NOT NULL,
    action VARCHAR(50) NOT NULL,
    user_email VARCHAR(255) NOT NULL,
    details JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

---

## EXISTING API ENDPOINTS

### Templates API (`/api/templates`)

| Method | Endpoint | Status | Description |
|--------|----------|--------|-------------|
| GET | `/` | ✅ | List templates with filters |
| GET | `/{id}` | ✅ | Get template by ID |
| POST | `/` | ✅ | Upload new template |
| PUT | `/{id}` | ✅ | Update template metadata |
| DELETE | `/{id}` | ✅ | Archive template |
| GET | `/{id}/content` | ✅ | Get HTML content |
| PUT | `/{id}/content` | ✅ | Save HTML with versioning |
| GET | `/{id}/settings` | ✅ | Get Vitec settings |
| PUT | `/{id}/settings` | ✅ | Update Vitec settings |
| GET | `/{id}/analyze` | ✅ | Analyze for merge fields |
| POST | `/{id}/thumbnail` | ✅ | Generate thumbnail |
| GET | `/{id}/download` | ✅ | Get download URL |

### Merge Fields API (`/api/merge-fields`)

| Method | Endpoint | Status | Description |
|--------|----------|--------|-------------|
| GET | `/` | ✅ | List with filters |
| GET | `/categories` | ✅ | Get category list |
| GET | `/autocomplete` | ✅ | Search suggestions |
| POST | `/scan` | ✅ | Discover from templates |
| GET | `/{id}` | ✅ | Get by ID |
| POST | `/` | ✅ | Create new field |
| PUT | `/{id}` | ✅ | Update field |
| DELETE | `/{id}` | ✅ | Delete field |

### Code Patterns API (`/api/code-patterns`)

| Method | Endpoint | Status | Description |
|--------|----------|--------|-------------|
| GET | `/` | ✅ | List with filters |
| GET | `/categories` | ✅ | Get category list |
| GET | `/{id}` | ✅ | Get by ID |
| POST | `/` | ✅ | Create pattern |
| PUT | `/{id}` | ✅ | Update pattern |
| DELETE | `/{id}` | ✅ | Delete pattern |
| POST | `/{id}/increment-usage` | ✅ | Track usage |

### Layout Partials API (`/api/layout-partials`)

| Method | Endpoint | Status | Description |
|--------|----------|--------|-------------|
| GET | `/` | ✅ | List with filters |
| GET | `/default` | ✅ | Get default by type/context |
| GET | `/{id}` | ✅ | Get by ID |
| POST | `/` | ✅ | Create partial |
| PUT | `/{id}` | ✅ | Update partial |
| DELETE | `/{id}` | ✅ | Delete partial |
| POST | `/{id}/set-default` | ✅ | Set as default |

### Dashboard API (`/api/dashboard`)

| Method | Endpoint | Status | Description |
|--------|----------|--------|-------------|
| GET | `/stats` | ✅ | Template counts |
| GET | `/inventory` | ✅ | Vitec sync status |

### Storage API (`/api/storage`)

| Method | Endpoint | Status | Description |
|--------|----------|--------|-------------|
| GET | `/list` | ✅ | List WebDAV directory |
| GET | `/file` | ✅ | Download file |
| POST | `/mkdir` | ✅ | Create directory |
| DELETE | `/` | ✅ | Delete file/directory |
| PUT | `/rename` | ✅ | Rename file |
| POST | `/copy` | ✅ | Copy file |
| POST | `/import` | ✅ | Import to library |

### Auth API (`/api/auth`)

| Method | Endpoint | Status | Description |
|--------|----------|--------|-------------|
| POST | `/login` | ✅ | Password login |
| POST | `/logout` | ✅ | End session |
| GET | `/status` | ✅ | Check auth status |

---

## V3.0 IMPLEMENTATION PLAN

### Phase 1: Merge Field Seeding (Priority: P0)

**Goal:** Populate merge_fields table with known Vitec fields from documentation.

#### 1.1 Seed Data Script

**File:** `backend/scripts/seed_merge_fields.py`

```python
"""
Seed script for Vitec merge fields.

Run with: python -m scripts.seed_merge_fields
"""

import asyncio
from app.database import async_engine, AsyncSession
from app.models.merge_field import MergeField
from sqlalchemy.dialects.postgresql import insert as pg_insert

# Vitec merge field definitions from vitec-reference.md
VITEC_MERGE_FIELDS = [
    # Eiendom (Property)
    {
        "path": "eiendom.adresse",
        "category": "Eiendom",
        "label": "Adresse",
        "description": "Eiendommens fulle adresse",
        "example_value": "Storgata 1, 0155 Oslo",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model"
    },
    {
        "path": "eiendom.postnummer",
        "category": "Eiendom",
        "label": "Postnummer",
        "description": "Eiendommens postnummer",
        "example_value": "0155",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model"
    },
    {
        "path": "eiendom.poststed",
        "category": "Eiendom",
        "label": "Poststed",
        "description": "Eiendommens poststed",
        "example_value": "Oslo",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model"
    },
    {
        "path": "eiendom.pris",
        "category": "Eiendom",
        "label": "Prisantydning",
        "description": "Eiendommens prisantydning",
        "example_value": "4 500 000",
        "data_type": "number",
        "is_iterable": False,
        "parent_model": "Model"
    },
    {
        "path": "eiendom.eieform",
        "category": "Eiendom",
        "label": "Eieform",
        "description": "Type eierskap (Eiet, Aksje, etc.)",
        "example_value": "Eiet",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model"
    },
    {
        "path": "eiendom.boligtype",
        "category": "Eiendom",
        "label": "Boligtype",
        "description": "Type bolig (Leilighet, Enebolig, etc.)",
        "example_value": "Leilighet",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model"
    },
    {
        "path": "eiendom.bra",
        "category": "Eiendom",
        "label": "BRA",
        "description": "Bruksareal i kvm",
        "example_value": "85",
        "data_type": "number",
        "is_iterable": False,
        "parent_model": "Model"
    },
    {
        "path": "eiendom.prom",
        "category": "Eiendom",
        "label": "P-ROM",
        "description": "Primærrom i kvm",
        "example_value": "78",
        "data_type": "number",
        "is_iterable": False,
        "parent_model": "Model"
    },
    
    # Selger (Seller)
    {
        "path": "selger.navn",
        "category": "Selger",
        "label": "Navn",
        "description": "Selgers fulle navn",
        "example_value": "Ola Nordmann",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model.selgere"
    },
    {
        "path": "selger.adresse",
        "category": "Selger",
        "label": "Adresse",
        "description": "Selgers adresse",
        "example_value": "Parkveien 10, 0350 Oslo",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model.selgere"
    },
    {
        "path": "selger.epost",
        "category": "Selger",
        "label": "E-post",
        "description": "Selgers e-postadresse",
        "example_value": "ola@example.com",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model.selgere"
    },
    {
        "path": "selger.telefon",
        "category": "Selger",
        "label": "Telefon",
        "description": "Selgers telefonnummer",
        "example_value": "912 34 567",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model.selgere"
    },
    
    # Kjøper (Buyer)
    {
        "path": "kjoper.navn",
        "category": "Kjøper",
        "label": "Navn",
        "description": "Kjøpers fulle navn",
        "example_value": "Kari Nordmann",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model.kjopere"
    },
    {
        "path": "kjoper.adresse",
        "category": "Kjøper",
        "label": "Adresse",
        "description": "Kjøpers adresse",
        "example_value": "Strandveien 5, 0252 Oslo",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model.kjopere"
    },
    {
        "path": "kjoper.epost",
        "category": "Kjøper",
        "label": "E-post",
        "description": "Kjøpers e-postadresse",
        "example_value": "kari@example.com",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model.kjopere"
    },
    
    # Megler (Broker)
    {
        "path": "ansvarligMegler.navn",
        "category": "Megler",
        "label": "Megler navn",
        "description": "Ansvarlig meglers navn",
        "example_value": "Per Hansen",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model"
    },
    {
        "path": "ansvarligMegler.tittel",
        "category": "Megler",
        "label": "Tittel",
        "description": "Meglers tittel",
        "example_value": "Eiendomsmegler MNEF",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model"
    },
    {
        "path": "ansvarligMegler.epost",
        "category": "Megler",
        "label": "E-post",
        "description": "Meglers e-postadresse",
        "example_value": "per@meglerkontor.no",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model"
    },
    {
        "path": "ansvarligMegler.telefon",
        "category": "Megler",
        "label": "Telefon",
        "description": "Meglers telefonnummer",
        "example_value": "22 33 44 55",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model"
    },
    
    # Meglerkontor (Office)
    {
        "path": "meglerkontor.navn",
        "category": "Megler",
        "label": "Kontor navn",
        "description": "Meglerkontorets navn",
        "example_value": "Proaktiv Eiendomsmegling AS",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model"
    },
    {
        "path": "meglerkontor.adresse",
        "category": "Megler",
        "label": "Kontor adresse",
        "description": "Meglerkontorets adresse",
        "example_value": "Stortingsgata 20, 0161 Oslo",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model"
    },
    {
        "path": "meglerkontor.orgnr",
        "category": "Megler",
        "label": "Org.nr",
        "description": "Meglerkontorets organisasjonsnummer",
        "example_value": "912 345 678",
        "data_type": "string",
        "is_iterable": False,
        "parent_model": "Model"
    },
    
    # Økonomi (Economy)
    {
        "path": "oppdrag.salgssum",
        "category": "Økonomi",
        "label": "Salgssum",
        "description": "Endelig salgssum",
        "example_value": "4 750 000",
        "data_type": "number",
        "is_iterable": False,
        "parent_model": "Model"
    },
    {
        "path": "oppdrag.overtagelse",
        "category": "Økonomi",
        "label": "Overtagelse",
        "description": "Dato for overtagelse",
        "example_value": "01.03.2026",
        "data_type": "date",
        "is_iterable": False,
        "parent_model": "Model"
    },
    {
        "path": "oppdrag.kontraktsdato",
        "category": "Økonomi",
        "label": "Kontraktsdato",
        "description": "Dato for kontraktsinngåelse",
        "example_value": "15.01.2026",
        "data_type": "date",
        "is_iterable": False,
        "parent_model": "Model"
    },
    
    # Dato (Dates)
    {
        "path": "dato.idag",
        "category": "Dato",
        "label": "Dagens dato",
        "description": "Dagens dato formatert",
        "example_value": "17. januar 2026",
        "data_type": "date",
        "is_iterable": False,
        "parent_model": "Model"
    },
    
    # Iterables (Collections)
    {
        "path": "Model.selgere",
        "category": "Samlinger",
        "label": "Selgere",
        "description": "Liste over alle selgere",
        "example_value": "[{navn: 'Ola'}, {navn: 'Kari'}]",
        "data_type": "array",
        "is_iterable": True,
        "parent_model": "Model"
    },
    {
        "path": "Model.kjopere",
        "category": "Samlinger",
        "label": "Kjøpere",
        "description": "Liste over alle kjøpere",
        "example_value": "[{navn: 'Per'}]",
        "data_type": "array",
        "is_iterable": True,
        "parent_model": "Model"
    },
    {
        "path": "Model.meglere",
        "category": "Samlinger",
        "label": "Meglere",
        "description": "Liste over alle involverte meglere",
        "example_value": "[{navn: 'Per Hansen'}]",
        "data_type": "array",
        "is_iterable": True,
        "parent_model": "Model"
    },
]


async def seed_merge_fields():
    """Seed merge fields using upsert (insert or update on conflict)."""
    async with AsyncSession(async_engine) as session:
        for field_data in VITEC_MERGE_FIELDS:
            # Use PostgreSQL INSERT ... ON CONFLICT for upsert
            stmt = pg_insert(MergeField).values(
                path=field_data["path"],
                category=field_data["category"],
                label=field_data["label"],
                description=field_data.get("description"),
                example_value=field_data.get("example_value"),
                data_type=field_data.get("data_type", "string"),
                is_iterable=field_data.get("is_iterable", False),
                parent_model=field_data.get("parent_model")
            ).on_conflict_do_update(
                index_elements=["path"],
                set_={
                    "category": field_data["category"],
                    "label": field_data["label"],
                    "description": field_data.get("description"),
                    "example_value": field_data.get("example_value"),
                    "data_type": field_data.get("data_type", "string"),
                    "is_iterable": field_data.get("is_iterable", False),
                    "parent_model": field_data.get("parent_model")
                }
            )
            await session.execute(stmt)
        
        await session.commit()
        print(f"Seeded {len(VITEC_MERGE_FIELDS)} merge fields")


if __name__ == "__main__":
    asyncio.run(seed_merge_fields())
```

#### 1.2 API Endpoint for Seeding

**Add to:** `backend/app/routers/admin.py`

```python
@router.post("/seed-merge-fields")
async def seed_merge_fields(
    db: AsyncSession = Depends(get_db),
    user: dict = Depends(get_current_user)
):
    """
    Seed merge fields from Vitec reference data.
    
    This is an admin-only operation that populates the merge_fields
    table with known Vitec fields.
    """
    from app.scripts.seed_merge_fields import VITEC_MERGE_FIELDS
    from sqlalchemy.dialects.postgresql import insert as pg_insert
    
    count = 0
    for field_data in VITEC_MERGE_FIELDS:
        stmt = pg_insert(MergeField).values(**field_data).on_conflict_do_update(
            index_elements=["path"],
            set_=field_data
        )
        await db.execute(stmt)
        count += 1
    
    await db.flush()
    return {"seeded": count, "message": f"Seeded {count} merge fields"}
```

---

### Phase 2: Version Restore API (Priority: P1)

**Goal:** Allow users to view version history and restore previous versions.

#### 2.1 New Endpoints

**Add to:** `backend/app/routers/templates.py`

```python
@router.get("/{template_id}/versions")
async def list_template_versions(
    template_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """
    Get version history for a template.
    
    Returns list of all versions with metadata, ordered by version_number desc.
    """
    template = await TemplateService.get_by_id(db, template_id)
    if not template:
        raise HTTPException(status_code=404, detail="Template not found")
    
    versions = sorted(template.versions, key=lambda v: v.version_number, reverse=True)
    
    return {
        "template_id": str(template_id),
        "current_version": template.version,
        "versions": [
            {
                "id": str(v.id),
                "version_number": v.version_number,
                "file_name": v.file_name,
                "file_size_bytes": v.file_size_bytes,
                "created_by": v.created_by,
                "change_notes": v.change_notes,
                "created_at": v.created_at.isoformat() if v.created_at else None
            }
            for v in versions
        ]
    }


@router.get("/{template_id}/versions/{version_number}/content")
async def get_version_content(
    template_id: UUID,
    version_number: int,
    db: AsyncSession = Depends(get_db)
):
    """
    Get the content of a specific version.
    
    Returns the HTML content stored in the version's blob URL.
    """
    template = await TemplateService.get_by_id(db, template_id)
    if not template:
        raise HTTPException(status_code=404, detail="Template not found")
    
    version = next(
        (v for v in template.versions if v.version_number == version_number),
        None
    )
    if not version:
        raise HTTPException(status_code=404, detail=f"Version {version_number} not found")
    
    # For now, versions store the content inline or reference storage
    # This may need enhancement based on how versions are stored
    return {
        "template_id": str(template_id),
        "version_number": version_number,
        "file_name": version.file_name,
        "change_notes": version.change_notes,
        "created_at": version.created_at.isoformat() if version.created_at else None,
        # Content would be fetched from storage - placeholder for now
        "content_available": True
    }


@router.post("/{template_id}/versions/{version_number}/restore")
async def restore_version(
    template_id: UUID,
    version_number: int,
    db: AsyncSession = Depends(get_db),
    user: dict = Depends(get_current_user)
):
    """
    Restore a previous version as the current version.
    
    Creates a new version from the restored content.
    """
    result = await TemplateVersionService.restore_version(
        db,
        template_id,
        version_number,
        restored_by=user["email"]
    )
    
    await AuditService.log(
        db,
        entity_type="template",
        entity_id=template_id,
        action="version_restored",
        user_email=user["email"],
        details={"from_version": version_number, "new_version": result["new_version"]}
    )
    
    return result
```

#### 2.2 Version Service Extension

**Add to:** `backend/app/services/template_version_service.py`

```python
"""
Template Version Service - Handles version history and restoration.
"""

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from typing import Optional
from uuid import UUID
from fastapi import HTTPException
import logging

from app.models.template import Template, TemplateVersion

logger = logging.getLogger(__name__)


class TemplateVersionService:
    """Service for template version operations."""
    
    @staticmethod
    async def restore_version(
        db: AsyncSession,
        template_id: UUID,
        version_number: int,
        *,
        restored_by: str
    ) -> dict:
        """
        Restore a previous version as the current version.
        
        Args:
            db: Database session
            template_id: Template UUID
            version_number: Version to restore
            restored_by: User email
            
        Returns:
            Dict with restoration details
            
        Raises:
            HTTPException: If template or version not found
        """
        # Get template
        result = await db.execute(
            select(Template).where(Template.id == str(template_id))
        )
        template = result.scalar_one_or_none()
        
        if not template:
            raise HTTPException(status_code=404, detail="Template not found")
        
        # Find the version to restore
        version_result = await db.execute(
            select(TemplateVersion)
            .where(TemplateVersion.template_id == str(template_id))
            .where(TemplateVersion.version_number == version_number)
        )
        version = version_result.scalar_one_or_none()
        
        if not version:
            raise HTTPException(
                status_code=404,
                detail=f"Version {version_number} not found"
            )
        
        # Create a snapshot of current state before restoring
        # This allows undoing the restore
        from app.services.template_content_service import TemplateContentService
        await TemplateContentService.create_version_snapshot(
            db,
            template,
            created_by=restored_by,
            change_notes=f"Snapshot before restoring version {version_number}"
        )
        
        # Restore the content (implementation depends on storage strategy)
        # For now, we assume content is stored or can be retrieved
        new_version = template.version + 1
        template.version = new_version
        template.updated_by = restored_by
        
        # Create version record for the restore action
        restore_version = TemplateVersion(
            template_id=str(template_id),
            version_number=new_version,
            file_name=template.file_name,
            azure_blob_url=template.azure_blob_url,
            file_size_bytes=template.file_size_bytes,
            created_by=restored_by,
            change_notes=f"Restored from version {version_number}"
        )
        db.add(restore_version)
        
        await db.flush()
        await db.refresh(template)
        
        logger.info(f"Restored template {template_id} from version {version_number} to {new_version}")
        
        return {
            "template_id": str(template_id),
            "restored_from": version_number,
            "new_version": new_version,
            "message": f"Successfully restored version {version_number}"
        }
```

---

### Phase 3: Bulk Operations (Priority: P2)

**Goal:** Enable multi-template operations for efficiency.

#### 3.1 Bulk Endpoints

**Add to:** `backend/app/routers/templates.py`

```python
from pydantic import BaseModel
from typing import List

class BulkActionRequest(BaseModel):
    """Request body for bulk operations."""
    template_ids: List[UUID]
    

class BulkStatusUpdate(BulkActionRequest):
    """Request body for bulk status change."""
    status: Literal['draft', 'published', 'archived']


class BulkCategoryUpdate(BulkActionRequest):
    """Request body for bulk category assignment."""
    category_ids: List[UUID]
    mode: Literal['add', 'replace', 'remove'] = 'add'


@router.post("/bulk/status")
async def bulk_update_status(
    body: BulkStatusUpdate,
    db: AsyncSession = Depends(get_db),
    user: dict = Depends(get_current_user)
):
    """
    Update status for multiple templates at once.
    
    Args:
        template_ids: List of template UUIDs
        status: New status to apply
        
    Returns:
        Summary of updated templates
    """
    updated = []
    failed = []
    
    for template_id in body.template_ids:
        try:
            template = await TemplateService.get_by_id(db, template_id)
            if template:
                template.status = body.status
                template.updated_by = user["email"]
                updated.append(str(template_id))
            else:
                failed.append({"id": str(template_id), "error": "Not found"})
        except Exception as e:
            failed.append({"id": str(template_id), "error": str(e)})
    
    await db.flush()
    
    return {
        "updated": len(updated),
        "failed": len(failed),
        "updated_ids": updated,
        "failed_details": failed
    }


@router.post("/bulk/categories")
async def bulk_update_categories(
    body: BulkCategoryUpdate,
    db: AsyncSession = Depends(get_db),
    user: dict = Depends(get_current_user)
):
    """
    Update categories for multiple templates.
    
    Modes:
    - add: Add categories to existing ones
    - replace: Replace all categories
    - remove: Remove specified categories
    """
    updated = []
    failed = []
    
    # Get the categories
    cats_result = await db.execute(
        select(Category).where(Category.id.in_(body.category_ids))
    )
    categories = list(cats_result.scalars().all())
    
    for template_id in body.template_ids:
        try:
            template = await TemplateService.get_by_id(db, template_id)
            if template:
                if body.mode == 'replace':
                    template.categories = categories
                elif body.mode == 'add':
                    existing_ids = {c.id for c in template.categories}
                    for cat in categories:
                        if cat.id not in existing_ids:
                            template.categories.append(cat)
                elif body.mode == 'remove':
                    remove_ids = {c.id for c in categories}
                    template.categories = [
                        c for c in template.categories if c.id not in remove_ids
                    ]
                
                template.updated_by = user["email"]
                updated.append(str(template_id))
            else:
                failed.append({"id": str(template_id), "error": "Not found"})
        except Exception as e:
            failed.append({"id": str(template_id), "error": str(e)})
    
    await db.flush()
    
    return {
        "updated": len(updated),
        "failed": len(failed),
        "mode": body.mode,
        "categories_applied": len(categories)
    }


@router.delete("/bulk")
async def bulk_delete(
    body: BulkActionRequest,
    db: AsyncSession = Depends(get_db),
    user: dict = Depends(get_current_user)
):
    """
    Archive multiple templates at once.
    
    Uses soft delete (status = 'archived').
    """
    archived = []
    failed = []
    
    for template_id in body.template_ids:
        try:
            template = await TemplateService.get_by_id(db, template_id)
            if template:
                template.status = 'archived'
                template.updated_by = user["email"]
                archived.append(str(template_id))
            else:
                failed.append({"id": str(template_id), "error": "Not found"})
        except Exception as e:
            failed.append({"id": str(template_id), "error": str(e)})
    
    await db.flush()
    
    return {
        "archived": len(archived),
        "failed": len(failed),
        "archived_ids": archived
    }
```

---

## FILE STRUCTURE ADDITIONS

```
backend/
├── scripts/
│   └── seed_merge_fields.py     # NEW - Merge field seed data
├── app/
│   └── services/
│       └── template_version_service.py  # NEW - Version management
```

---

## IMPLEMENTATION ORDER

### Phase 1: Merge Field Seeding (This Sprint)
1. Create `seed_merge_fields.py` with Vitec field definitions
2. Add `/api/admin/seed-merge-fields` endpoint
3. Run seed script on production
4. Test: Flettekoder page shows seeded fields

### Phase 2: Version History (Next Sprint)
5. Create `template_version_service.py`
6. Add version list/restore endpoints
7. Test: Can view and restore previous versions

### Phase 3: Bulk Operations (Future)
8. Add bulk status update endpoint
9. Add bulk category update endpoint
10. Add bulk delete endpoint
11. Test: Can update multiple templates at once

---

## TEST CRITERIA

### Phase 1: Merge Field Seeding
- [ ] `/api/admin/seed-merge-fields` creates ~25+ merge fields
- [ ] Seeding is idempotent (can run multiple times)
- [ ] Flettekoder page displays all categories
- [ ] Auto-discovery still works for unknown fields

### Phase 2: Version History
- [ ] `GET /api/templates/{id}/versions` returns version list
- [ ] `POST /api/templates/{id}/versions/{n}/restore` restores correctly
- [ ] Restore creates a snapshot before changing
- [ ] Audit log tracks restore operations

### Phase 3: Bulk Operations
- [ ] `POST /api/templates/bulk/status` updates multiple templates
- [ ] `POST /api/templates/bulk/categories` handles add/replace/remove modes
- [ ] `DELETE /api/templates/bulk` archives multiple templates
- [ ] Failed operations don't roll back successful ones

---

## CONTEXT FILE UPDATES

### `.cursorrules` - Already up to date for V2.9

The current `.cursorrules` file includes all necessary backend patterns:
- Service pattern (business logic in services)
- UUID for primary keys
- JSONB for arrays
- Async service methods
- Template content/settings flow

### `.cursor/active_context.md` - Update Phase Info

Update the phase to reflect V2.9 completion and V3.0 planning:

```markdown
## PROJECT STATUS
- **Phase:** 3.0 (Enhancement & Polish)
- **Current Sprint:** Merge Field Seeding + Version History UI
- **Last Milestone:** ✅ V2.9 Vitec Integration Complete (2026-01-17)
```

---

## HANDOFF TO FRONTEND ARCHITECT

The frontend needs to:
1. Display merge field seeding status on Flettekoder page
2. Add version history panel to template viewer
3. Implement version restore confirmation dialog
4. Add bulk selection mode to template library
5. Create bulk action toolbar with status/category/delete options

---

**Next Step:** Invoke **FRONTEND ARCHITECT** agent to create updated `frontend_spec.md`
