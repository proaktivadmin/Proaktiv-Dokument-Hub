# BACKEND SPECIFICATION - V2 Document Hub

**Generated by:** Systems Architect Agent  
**Date:** 2026-01-14  
**Phase:** 2.1 (Document-First MVP)

---

## T1: DATABASE MIGRATIONS

### Migration 1: Template Vitec Metadata Fields

```sql
-- Migration: YYYYMMDD01_add_vitec_metadata_to_templates.py
-- Description: Add Vitec-compatible metadata fields to templates table

ALTER TABLE templates
  ADD COLUMN IF NOT EXISTS preview_thumbnail_url TEXT,
  ADD COLUMN IF NOT EXISTS channel VARCHAR(20) DEFAULT 'pdf_email',
  ADD COLUMN IF NOT EXISTS template_type VARCHAR(50) DEFAULT 'Objekt/Kontakt',
  ADD COLUMN IF NOT EXISTS receiver_type VARCHAR(50),
  ADD COLUMN IF NOT EXISTS receiver VARCHAR(100),
  ADD COLUMN IF NOT EXISTS extra_receivers JSONB DEFAULT '[]',
  ADD COLUMN IF NOT EXISTS phases JSONB DEFAULT '[]',
  ADD COLUMN IF NOT EXISTS assignment_types JSONB DEFAULT '[]',
  ADD COLUMN IF NOT EXISTS ownership_types JSONB DEFAULT '[]',
  ADD COLUMN IF NOT EXISTS departments JSONB DEFAULT '[]',
  ADD COLUMN IF NOT EXISTS email_subject VARCHAR(500),
  ADD COLUMN IF NOT EXISTS header_template_id UUID,
  ADD COLUMN IF NOT EXISTS footer_template_id UUID,
  ADD COLUMN IF NOT EXISTS margin_top DECIMAL(4,2) DEFAULT 1.5,
  ADD COLUMN IF NOT EXISTS margin_bottom DECIMAL(4,2) DEFAULT 1.0,
  ADD COLUMN IF NOT EXISTS margin_left DECIMAL(4,2) DEFAULT 1.0,
  ADD COLUMN IF NOT EXISTS margin_right DECIMAL(4,2) DEFAULT 1.2;

-- Channel values: 'pdf', 'email', 'sms', 'pdf_email'
COMMENT ON COLUMN templates.channel IS 'Template channel: pdf, email, sms, pdf_email';

-- Foreign key constraints added after layout_partials table exists
-- See Migration 4 for FK constraints
```

### Migration 2: Merge Fields Table

```sql
-- Migration: YYYYMMDD02_create_merge_fields.py
-- Description: Create merge_fields table for Flettekode system

CREATE TABLE IF NOT EXISTS merge_fields (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    path VARCHAR(200) UNIQUE NOT NULL,
    category VARCHAR(100) NOT NULL,
    label VARCHAR(200) NOT NULL,
    description TEXT,
    example_value VARCHAR(500),
    data_type VARCHAR(50) DEFAULT 'string',
    is_iterable BOOLEAN DEFAULT FALSE,
    parent_model VARCHAR(100),
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_merge_fields_category ON merge_fields(category);
CREATE INDEX IF NOT EXISTS idx_merge_fields_path ON merge_fields(path);
CREATE INDEX IF NOT EXISTS idx_merge_fields_parent_model ON merge_fields(parent_model);

-- Comments
COMMENT ON TABLE merge_fields IS 'Vitec merge field registry for Flettekode system';
COMMENT ON COLUMN merge_fields.path IS 'Merge field path e.g. eiendom.adresse, selger.navn';
COMMENT ON COLUMN merge_fields.data_type IS 'Data type: string, number, date, boolean, array';
COMMENT ON COLUMN merge_fields.is_iterable IS 'True if can be used with vitec-foreach';
```

### Migration 3: Code Patterns Table

```sql
-- Migration: YYYYMMDD03_create_code_patterns.py
-- Description: Create code_patterns table for reusable HTML/Vitec snippets

CREATE TABLE IF NOT EXISTS code_patterns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(200) NOT NULL,
    category VARCHAR(100) NOT NULL,
    description TEXT,
    html_code TEXT NOT NULL,
    variables_used JSONB DEFAULT '[]',
    preview_thumbnail_url TEXT,
    usage_count INTEGER DEFAULT 0,
    created_by VARCHAR(255) NOT NULL,
    updated_by VARCHAR(255) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_code_patterns_category ON code_patterns(category);
CREATE INDEX IF NOT EXISTS idx_code_patterns_name ON code_patterns(name);

-- Comments
COMMENT ON TABLE code_patterns IS 'Reusable code patterns for template building';
COMMENT ON COLUMN code_patterns.variables_used IS 'Array of merge_field paths used in this pattern';
```

### Migration 4: Layout Partials Table

```sql
-- Migration: YYYYMMDD04_create_layout_partials.py
-- Description: Create layout_partials table for headers/footers

CREATE TABLE IF NOT EXISTS layout_partials (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(200) NOT NULL,
    type VARCHAR(20) NOT NULL CHECK (type IN ('header', 'footer')),
    context VARCHAR(50) DEFAULT 'all' CHECK (context IN ('pdf', 'email', 'all')),
    html_content TEXT NOT NULL,
    is_default BOOLEAN DEFAULT FALSE,
    created_by VARCHAR(255) NOT NULL,
    updated_by VARCHAR(255) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_layout_partials_type ON layout_partials(type);
CREATE INDEX IF NOT EXISTS idx_layout_partials_context ON layout_partials(context);
CREATE INDEX IF NOT EXISTS idx_layout_partials_is_default ON layout_partials(is_default);

-- Now add FK constraints to templates
ALTER TABLE templates
  ADD CONSTRAINT fk_templates_header_template_id 
    FOREIGN KEY (header_template_id) REFERENCES layout_partials(id) ON DELETE SET NULL,
  ADD CONSTRAINT fk_templates_footer_template_id 
    FOREIGN KEY (footer_template_id) REFERENCES layout_partials(id) ON DELETE SET NULL;

-- Comments
COMMENT ON TABLE layout_partials IS 'Reusable header and footer templates';
COMMENT ON COLUMN layout_partials.type IS 'Partial type: header or footer';
COMMENT ON COLUMN layout_partials.context IS 'Usage context: pdf, email, or all';
```

### Migration 5: Seed Merge Fields from snippets.json

```sql
-- Migration: YYYYMMDD05_seed_merge_fields.py
-- Description: Seed merge_fields table from resources/snippets.json
-- Note: This should be implemented as a Python migration using the data from snippets.json

-- Selger fields
INSERT INTO merge_fields (path, category, label, description, example_value, data_type, is_iterable, parent_model)
VALUES
  ('selger.navnutenfullmektigogkontaktperson', 'Selger', 'Navn (Full)', 'Navn uten fullmektig', 'Ola Nordmann', 'string', TRUE, 'Model.selgere'),
  ('selger.hovedgatenavnognr', 'Selger', 'Adresse', 'Gate og nr', 'Storgata 1', 'string', TRUE, 'Model.selgere'),
  ('selger.hovedpostnr', 'Selger', 'Postnummer', 'Postnummer', '0123', 'string', TRUE, 'Model.selgere'),
  ('selger.hovedpoststed', 'Selger', 'Poststed', 'Poststed', 'Oslo', 'string', TRUE, 'Model.selgere'),
  ('selger.emailadresse', 'Selger', 'E-post', 'Email adresse', 'ola@example.com', 'string', TRUE, 'Model.selgere'),
  ('selger.hovedtlf', 'Selger', 'Telefon', 'Hovedtelefon', '+47 123 45 678', 'string', TRUE, 'Model.selgere'),
  ('selger.idnummer', 'Selger', 'Fødselsnr', 'ID nummer', '010180*****', 'string', TRUE, 'Model.selgere')
ON CONFLICT (path) DO NOTHING;

-- Eiendom fields
INSERT INTO merge_fields (path, category, label, description, example_value, data_type, is_iterable, parent_model)
VALUES
  ('eiendom.gatenavnognr', 'Eiendom', 'Adresse', 'Gatenavn og nr', 'Parkveien 10', 'string', FALSE, 'Model.eiendom'),
  ('eiendom.postnr', 'Eiendom', 'Postnummer', 'Postnummer', '0350', 'string', FALSE, 'Model.eiendom'),
  ('eiendom.poststed', 'Eiendom', 'Poststed', 'Poststed', 'Oslo', 'string', FALSE, 'Model.eiendom'),
  ('komplettmatrikkelutvidet', 'Eiendom', 'Matrikkel', 'Komplett matrikkel', 'Gnr 1 Bnr 23', 'string', FALSE, NULL),
  ('eiendom.boligtype', 'Eiendom', 'Boligtype', 'Type bolig', 'Leilighet', 'string', FALSE, 'Model.eiendom'),
  ('eiendom.pris', 'Eiendom', 'Prisantydning', 'Pris', '5 900 000', 'number', FALSE, 'Model.eiendom')
ON CONFLICT (path) DO NOTHING;

-- Megler fields
INSERT INTO merge_fields (path, category, label, description, example_value, data_type, is_iterable, parent_model)
VALUES
  ('ansvarligmegler.navn', 'Megler', 'Ansvarlig Navn', 'Megler navn', 'Kari Meglersen', 'string', FALSE, 'Model.ansvarligmegler'),
  ('ansvarligmegler.tittel', 'Megler', 'Ansvarlig Tittel', 'Megler tittel', 'Eiendomsmegler MNEF', 'string', FALSE, 'Model.ansvarligmegler'),
  ('meglerkontor.markedsforingsnavn', 'Megler', 'Kontor Navn', 'Markedsføringsnavn', 'Proaktiv Eiendom AS', 'string', FALSE, 'Model.meglerkontor'),
  ('meglerkontor.besoksadresse', 'Megler', 'Kontor Adresse', 'Besøksadresse', 'Torggata 5, Oslo', 'string', FALSE, 'Model.meglerkontor'),
  ('oppgjor.kontornavn', 'Megler', 'Oppgjør Navn', 'Oppgjørsavdeling', 'Proaktiv Oppgjør', 'string', FALSE, 'Model.oppgjor')
ON CONFLICT (path) DO NOTHING;

-- Økonomi fields
INSERT INTO merge_fields (path, category, label, description, example_value, data_type, is_iterable, parent_model)
VALUES
  ('oppdrag.provisjonprosent', 'Økonomi', 'Provisjon %', 'Sats', '2.5', 'number', FALSE, 'Model.oppdrag'),
  ('oppdrag.selgersamletsum', 'Økonomi', 'Samlet Sum', 'Selger samlet sum', '125 000', 'number', FALSE, 'Model.oppdrag'),
  ('oppdrag.selgerutleggsum', 'Økonomi', 'Utlegg Sum', 'Sum utlegg', '25 000', 'number', FALSE, 'Model.oppdrag')
ON CONFLICT (path) DO NOTHING;
```

---

## T2: PYDANTIC SCHEMAS

### File: `backend/app/schemas/merge_field.py`

```python
"""
Pydantic schemas for Merge Field operations.
"""

from pydantic import BaseModel, Field, ConfigDict
from typing import Optional, List
from uuid import UUID
from datetime import datetime


class MergeFieldBase(BaseModel):
    """Base schema for merge field data."""
    path: str = Field(..., max_length=200, description="Merge field path e.g. eiendom.adresse")
    category: str = Field(..., max_length=100, description="Category e.g. Selger, Eiendom")
    label: str = Field(..., max_length=200, description="Display label")
    description: Optional[str] = Field(None, description="Detailed description")
    example_value: Optional[str] = Field(None, max_length=500, description="Example value")
    data_type: str = Field("string", description="Data type: string, number, date, boolean, array")
    is_iterable: bool = Field(False, description="Can be used with vitec-foreach")
    parent_model: Optional[str] = Field(None, max_length=100, description="Parent model path")


class MergeFieldCreate(MergeFieldBase):
    """Schema for creating a merge field."""
    pass


class MergeFieldUpdate(BaseModel):
    """Schema for updating a merge field (all fields optional)."""
    path: Optional[str] = Field(None, max_length=200)
    category: Optional[str] = Field(None, max_length=100)
    label: Optional[str] = Field(None, max_length=200)
    description: Optional[str] = None
    example_value: Optional[str] = Field(None, max_length=500)
    data_type: Optional[str] = None
    is_iterable: Optional[bool] = None
    parent_model: Optional[str] = Field(None, max_length=100)


class MergeFieldResponse(MergeFieldBase):
    """Schema for merge field response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    usage_count: int = 0
    created_at: datetime
    updated_at: datetime


class MergeFieldListResponse(BaseModel):
    """Schema for paginated merge field list response."""
    merge_fields: List[MergeFieldResponse]
    total: int
    page: int
    per_page: int
    total_pages: int


class MergeFieldDiscoveryResult(BaseModel):
    """Schema for merge field auto-discovery result."""
    discovered_count: int
    new_fields: List[str]
    existing_fields: List[str]
    templates_scanned: int
```

### File: `backend/app/schemas/code_pattern.py`

```python
"""
Pydantic schemas for Code Pattern operations.
"""

from pydantic import BaseModel, Field, ConfigDict
from typing import Optional, List
from uuid import UUID
from datetime import datetime


class CodePatternBase(BaseModel):
    """Base schema for code pattern data."""
    name: str = Field(..., max_length=200, description="Pattern name")
    category: str = Field(..., max_length=100, description="Category e.g. Tabeller, Betingelser")
    description: Optional[str] = Field(None, description="Description of the pattern")
    html_code: str = Field(..., description="HTML/Vitec code content")
    variables_used: List[str] = Field(default_factory=list, description="List of merge field paths used")


class CodePatternCreate(CodePatternBase):
    """Schema for creating a code pattern."""
    pass


class CodePatternUpdate(BaseModel):
    """Schema for updating a code pattern (all fields optional)."""
    name: Optional[str] = Field(None, max_length=200)
    category: Optional[str] = Field(None, max_length=100)
    description: Optional[str] = None
    html_code: Optional[str] = None
    variables_used: Optional[List[str]] = None


class CodePatternResponse(CodePatternBase):
    """Schema for code pattern response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    preview_thumbnail_url: Optional[str] = None
    usage_count: int = 0
    created_by: str
    updated_by: str
    created_at: datetime
    updated_at: datetime


class CodePatternListResponse(BaseModel):
    """Schema for paginated code pattern list response."""
    patterns: List[CodePatternResponse]
    total: int
    page: int
    per_page: int
    total_pages: int
```

### File: `backend/app/schemas/layout_partial.py`

```python
"""
Pydantic schemas for Layout Partial operations.
"""

from pydantic import BaseModel, Field, ConfigDict
from typing import Optional, List, Literal
from uuid import UUID
from datetime import datetime


class LayoutPartialBase(BaseModel):
    """Base schema for layout partial data."""
    name: str = Field(..., max_length=200, description="Partial name")
    type: Literal['header', 'footer'] = Field(..., description="Partial type")
    context: Literal['pdf', 'email', 'all'] = Field('all', description="Usage context")
    html_content: str = Field(..., description="HTML content")


class LayoutPartialCreate(LayoutPartialBase):
    """Schema for creating a layout partial."""
    is_default: bool = Field(False, description="Set as default for type/context")


class LayoutPartialUpdate(BaseModel):
    """Schema for updating a layout partial (all fields optional)."""
    name: Optional[str] = Field(None, max_length=200)
    type: Optional[Literal['header', 'footer']] = None
    context: Optional[Literal['pdf', 'email', 'all']] = None
    html_content: Optional[str] = None
    is_default: Optional[bool] = None


class LayoutPartialResponse(LayoutPartialBase):
    """Schema for layout partial response."""
    model_config = ConfigDict(from_attributes=True)
    
    id: UUID
    is_default: bool
    created_by: str
    updated_by: str
    created_at: datetime
    updated_at: datetime


class LayoutPartialListResponse(BaseModel):
    """Schema for paginated layout partial list response."""
    partials: List[LayoutPartialResponse]
    total: int


class LayoutPartialSetDefaultResponse(BaseModel):
    """Schema for set default operation response."""
    id: UUID
    is_default: bool
    previous_default_id: Optional[UUID] = None
```

### File: `backend/app/schemas/template_metadata.py`

```python
"""
Pydantic schemas for extended Template Metadata (Vitec parity).
"""

from pydantic import BaseModel, Field, ConfigDict
from typing import Optional, List, Literal
from uuid import UUID
from decimal import Decimal


class TemplateMetadataUpdate(BaseModel):
    """
    Schema for updating template Vitec metadata fields.
    All fields are optional for partial updates.
    """
    # Channel and Type
    channel: Optional[Literal['pdf', 'email', 'sms', 'pdf_email']] = Field(
        None, description="Template channel type"
    )
    template_type: Optional[Literal['Objekt/Kontakt', 'System']] = Field(
        None, description="Template type"
    )
    
    # Receiver
    receiver_type: Optional[Literal['Egne/kundetilpasset', 'Systemstandard']] = Field(
        None, description="Receiver type"
    )
    receiver: Optional[Literal['Selger', 'Kjøper', 'Megler', 'Bank', 'Forretningsfører']] = Field(
        None, description="Primary receiver"
    )
    extra_receivers: Optional[List[str]] = Field(
        None, description="Additional receivers"
    )
    
    # Filtering/Categorization
    phases: Optional[List[Literal['Oppdrag', 'Markedsføring', 'Visning', 'Budrunde', 'Kontrakt', 'Oppgjør']]] = Field(
        None, description="Applicable phases"
    )
    assignment_types: Optional[List[str]] = Field(
        None, description="Assignment types"
    )
    ownership_types: Optional[List[Literal['Bolig', 'Aksje', 'Tomt', 'Næring', 'Hytte']]] = Field(
        None, description="Ownership types"
    )
    departments: Optional[List[str]] = Field(
        None, description="Departments"
    )
    
    # Email
    email_subject: Optional[str] = Field(
        None, max_length=500, description="Email subject line (can include merge fields)"
    )
    
    # Layout
    header_template_id: Optional[UUID] = Field(
        None, description="Header layout partial ID"
    )
    footer_template_id: Optional[UUID] = Field(
        None, description="Footer layout partial ID"
    )
    
    # Margins (in cm)
    margin_top: Optional[Decimal] = Field(
        None, ge=0, le=10, description="Top margin in cm"
    )
    margin_bottom: Optional[Decimal] = Field(
        None, ge=0, le=10, description="Bottom margin in cm"
    )
    margin_left: Optional[Decimal] = Field(
        None, ge=0, le=10, description="Left margin in cm"
    )
    margin_right: Optional[Decimal] = Field(
        None, ge=0, le=10, description="Right margin in cm"
    )
    
    # Thumbnail
    preview_thumbnail_url: Optional[str] = Field(
        None, description="Preview thumbnail URL"
    )


class TemplateAnalysisResult(BaseModel):
    """Schema for template analysis result."""
    template_id: UUID
    merge_fields_found: List[str]
    conditions_found: List[str]
    loops_found: List[str]
    unknown_fields: List[str]
    analysis_timestamp: str
```

---

## T3: SERVICE INTERFACES

### File: `backend/app/services/merge_field_service.py`

```python
"""
Merge Field Service - Business logic for Flettekode operations.
"""

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, or_
from typing import Optional, List, Tuple
from uuid import UUID
import re
import logging

from app.models.merge_field import MergeField
from app.models.template import Template

logger = logging.getLogger(__name__)


class MergeFieldService:
    """
    Service class for merge field CRUD and discovery operations.
    
    Handles the Flettekode system including:
    - CRUD operations for merge fields
    - Auto-discovery of fields from templates
    - Search and filtering
    """
    
    # Regex patterns for Vitec merge field syntax
    MERGE_FIELD_PATTERN = re.compile(r'\[\[(\*?)([^\]]+)\]\]')
    VITEC_IF_PATTERN = re.compile(r'vitec-if="([^"]+)"')
    VITEC_FOREACH_PATTERN = re.compile(r'vitec-foreach="(\w+)\s+in\s+([^"]+)"')
    
    @staticmethod
    async def get_list(
        db: AsyncSession,
        *,
        category: Optional[str] = None,
        search: Optional[str] = None,
        data_type: Optional[str] = None,
        is_iterable: Optional[bool] = None,
        page: int = 1,
        per_page: int = 50
    ) -> Tuple[List[MergeField], int]:
        """
        Get paginated list of merge fields with filters.
        
        Args:
            db: Database session
            category: Filter by category name
            search: Search in path, label, description
            data_type: Filter by data type
            is_iterable: Filter by iterable flag
            page: Page number (1-indexed)
            per_page: Items per page
            
        Returns:
            Tuple of (merge_fields list, total count)
        """
        pass
    
    @staticmethod
    async def get_by_id(db: AsyncSession, field_id: UUID) -> Optional[MergeField]:
        """
        Get a merge field by ID.
        
        Args:
            db: Database session
            field_id: Merge field UUID
            
        Returns:
            MergeField or None if not found
        """
        pass
    
    @staticmethod
    async def get_by_path(db: AsyncSession, path: str) -> Optional[MergeField]:
        """
        Get a merge field by its path.
        
        Args:
            db: Database session
            path: Field path (e.g., 'selger.navn')
            
        Returns:
            MergeField or None if not found
        """
        pass
    
    @staticmethod
    async def create(
        db: AsyncSession,
        *,
        path: str,
        category: str,
        label: str,
        description: Optional[str] = None,
        example_value: Optional[str] = None,
        data_type: str = "string",
        is_iterable: bool = False,
        parent_model: Optional[str] = None
    ) -> MergeField:
        """
        Create a new merge field.
        
        Args:
            db: Database session
            path: Unique field path
            category: Category name
            label: Display label
            description: Optional description
            example_value: Example value for preview
            data_type: Data type (string, number, date, boolean, array)
            is_iterable: Whether field can be used in foreach
            parent_model: Parent model path
            
        Returns:
            Created merge field
            
        Raises:
            HTTPException: If path already exists
        """
        pass
    
    @staticmethod
    async def update(
        db: AsyncSession,
        field: MergeField,
        **updates
    ) -> MergeField:
        """
        Update a merge field.
        
        Args:
            db: Database session
            field: MergeField to update
            **updates: Fields to update
            
        Returns:
            Updated merge field
        """
        pass
    
    @staticmethod
    async def delete(db: AsyncSession, field: MergeField) -> None:
        """
        Delete a merge field.
        
        Args:
            db: Database session
            field: MergeField to delete
        """
        pass
    
    @staticmethod
    async def get_categories(db: AsyncSession) -> List[str]:
        """
        Get list of all unique categories.
        
        Args:
            db: Database session
            
        Returns:
            List of category names
        """
        pass
    
    @staticmethod
    async def search_autocomplete(
        db: AsyncSession,
        query: str,
        limit: int = 10
    ) -> List[MergeField]:
        """
        Search merge fields for autocomplete suggestions.
        
        Args:
            db: Database session
            query: Search query
            limit: Maximum results
            
        Returns:
            List of matching merge fields
        """
        pass
    
    @classmethod
    async def discover_from_template(
        cls,
        db: AsyncSession,
        template: Template
    ) -> dict:
        """
        Extract merge fields from a single template's content.
        
        Args:
            db: Database session
            template: Template to analyze
            
        Returns:
            Dict with discovered fields, conditions, loops
        """
        pass
    
    @classmethod
    async def discover_all(
        cls,
        db: AsyncSession,
        *,
        create_missing: bool = True
    ) -> dict:
        """
        Scan all templates and discover merge fields.
        
        Args:
            db: Database session
            create_missing: If True, create new MergeField records for unknown fields
            
        Returns:
            Dict with discovery statistics
        """
        pass
    
    @staticmethod
    async def increment_usage(db: AsyncSession, field_id: UUID) -> None:
        """
        Increment usage count for a merge field.
        
        Args:
            db: Database session
            field_id: Merge field UUID
        """
        pass
```

### File: `backend/app/services/code_pattern_service.py`

```python
"""
Code Pattern Service - Business logic for reusable code patterns.
"""

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, or_
from typing import Optional, List, Tuple
from uuid import UUID
import logging

from app.models.code_pattern import CodePattern

logger = logging.getLogger(__name__)


class CodePatternService:
    """
    Service class for code pattern CRUD operations.
    
    Handles reusable HTML/Vitec code snippets.
    """
    
    @staticmethod
    async def get_list(
        db: AsyncSession,
        *,
        category: Optional[str] = None,
        search: Optional[str] = None,
        page: int = 1,
        per_page: int = 20
    ) -> Tuple[List[CodePattern], int]:
        """
        Get paginated list of code patterns with filters.
        
        Args:
            db: Database session
            category: Filter by category
            search: Search in name, description
            page: Page number (1-indexed)
            per_page: Items per page
            
        Returns:
            Tuple of (patterns list, total count)
        """
        pass
    
    @staticmethod
    async def get_by_id(db: AsyncSession, pattern_id: UUID) -> Optional[CodePattern]:
        """
        Get a code pattern by ID.
        
        Args:
            db: Database session
            pattern_id: Pattern UUID
            
        Returns:
            CodePattern or None
        """
        pass
    
    @staticmethod
    async def create(
        db: AsyncSession,
        *,
        name: str,
        category: str,
        html_code: str,
        created_by: str,
        description: Optional[str] = None,
        variables_used: Optional[List[str]] = None
    ) -> CodePattern:
        """
        Create a new code pattern.
        
        Args:
            db: Database session
            name: Pattern name
            category: Category
            html_code: HTML/Vitec code
            created_by: User email
            description: Optional description
            variables_used: List of merge field paths
            
        Returns:
            Created pattern
        """
        pass
    
    @staticmethod
    async def update(
        db: AsyncSession,
        pattern: CodePattern,
        *,
        updated_by: str,
        **updates
    ) -> CodePattern:
        """
        Update a code pattern.
        
        Args:
            db: Database session
            pattern: Pattern to update
            updated_by: User email
            **updates: Fields to update
            
        Returns:
            Updated pattern
        """
        pass
    
    @staticmethod
    async def delete(db: AsyncSession, pattern: CodePattern) -> None:
        """
        Delete a code pattern.
        
        Args:
            db: Database session
            pattern: Pattern to delete
        """
        pass
    
    @staticmethod
    async def get_categories(db: AsyncSession) -> List[str]:
        """
        Get list of all unique categories.
        
        Args:
            db: Database session
            
        Returns:
            List of category names
        """
        pass
    
    @staticmethod
    async def increment_usage(db: AsyncSession, pattern_id: UUID) -> None:
        """
        Increment usage count for a code pattern.
        
        Args:
            db: Database session
            pattern_id: Pattern UUID
        """
        pass
```

### File: `backend/app/services/layout_partial_service.py`

```python
"""
Layout Partial Service - Business logic for headers and footers.
"""

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, update
from typing import Optional, List, Literal
from uuid import UUID
import logging

from app.models.layout_partial import LayoutPartial

logger = logging.getLogger(__name__)


class LayoutPartialService:
    """
    Service class for layout partial (header/footer) operations.
    """
    
    @staticmethod
    async def get_list(
        db: AsyncSession,
        *,
        type_filter: Optional[Literal['header', 'footer']] = None,
        context_filter: Optional[Literal['pdf', 'email', 'all']] = None
    ) -> List[LayoutPartial]:
        """
        Get list of layout partials with filters.
        
        Args:
            db: Database session
            type_filter: Filter by type (header/footer)
            context_filter: Filter by context (pdf/email/all)
            
        Returns:
            List of layout partials
        """
        pass
    
    @staticmethod
    async def get_by_id(db: AsyncSession, partial_id: UUID) -> Optional[LayoutPartial]:
        """
        Get a layout partial by ID.
        
        Args:
            db: Database session
            partial_id: Partial UUID
            
        Returns:
            LayoutPartial or None
        """
        pass
    
    @staticmethod
    async def get_default(
        db: AsyncSession,
        *,
        type_filter: Literal['header', 'footer'],
        context_filter: Literal['pdf', 'email', 'all'] = 'all'
    ) -> Optional[LayoutPartial]:
        """
        Get the default partial for a type/context combination.
        
        Args:
            db: Database session
            type_filter: Type (header/footer)
            context_filter: Context (pdf/email/all)
            
        Returns:
            Default LayoutPartial or None
        """
        pass
    
    @staticmethod
    async def create(
        db: AsyncSession,
        *,
        name: str,
        type: Literal['header', 'footer'],
        html_content: str,
        created_by: str,
        context: Literal['pdf', 'email', 'all'] = 'all',
        is_default: bool = False
    ) -> LayoutPartial:
        """
        Create a new layout partial.
        
        Args:
            db: Database session
            name: Partial name
            type: Type (header/footer)
            html_content: HTML content
            created_by: User email
            context: Usage context
            is_default: Set as default
            
        Returns:
            Created partial
        """
        pass
    
    @staticmethod
    async def update(
        db: AsyncSession,
        partial: LayoutPartial,
        *,
        updated_by: str,
        **updates
    ) -> LayoutPartial:
        """
        Update a layout partial.
        
        Args:
            db: Database session
            partial: Partial to update
            updated_by: User email
            **updates: Fields to update
            
        Returns:
            Updated partial
        """
        pass
    
    @staticmethod
    async def delete(db: AsyncSession, partial: LayoutPartial) -> None:
        """
        Delete a layout partial.
        
        Args:
            db: Database session
            partial: Partial to delete
            
        Raises:
            HTTPException: If partial is in use by templates
        """
        pass
    
    @staticmethod
    async def set_default(
        db: AsyncSession,
        partial: LayoutPartial
    ) -> Optional[UUID]:
        """
        Set a partial as the default for its type/context.
        Unsets any existing default.
        
        Args:
            db: Database session
            partial: Partial to set as default
            
        Returns:
            UUID of previous default (if any)
        """
        pass
```

### File: `backend/app/services/template_analyzer_service.py`

```python
"""
Template Analyzer Service - Analyzes templates for merge fields and patterns.
"""

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from typing import List, Optional
from uuid import UUID
import re
import logging

from app.models.template import Template
from app.models.merge_field import MergeField

logger = logging.getLogger(__name__)


class TemplateAnalyzerService:
    """
    Service for analyzing template content.
    
    Extracts merge fields, conditions, and loops from template HTML.
    """
    
    # Regex patterns
    MERGE_FIELD_PATTERN = re.compile(r'\[\[(\*?)([^\]]+)\]\]')
    VITEC_IF_PATTERN = re.compile(r'vitec-if="([^"]+)"')
    VITEC_FOREACH_PATTERN = re.compile(r'vitec-foreach="(\w+)\s+in\s+([^"]+)"')
    
    @classmethod
    async def analyze(
        cls,
        db: AsyncSession,
        template_id: UUID
    ) -> dict:
        """
        Analyze a single template and return all discovered elements.
        
        Args:
            db: Database session
            template_id: Template UUID to analyze
            
        Returns:
            Dict containing:
            - template_id: UUID
            - merge_fields_found: List[str] - paths of merge fields
            - conditions_found: List[str] - condition expressions
            - loops_found: List[dict] - loop variable and collection pairs
            - unknown_fields: List[str] - fields not in merge_fields table
            - analysis_timestamp: ISO timestamp
            
        Raises:
            HTTPException: If template not found or not HTML
        """
        pass
    
    @classmethod
    async def scan_all(
        cls,
        db: AsyncSession,
        *,
        update_usage_counts: bool = True
    ) -> dict:
        """
        Scan all HTML templates in the database.
        
        Args:
            db: Database session
            update_usage_counts: If True, update merge field usage counts
            
        Returns:
            Dict containing:
            - templates_scanned: int
            - total_merge_fields: int
            - total_conditions: int
            - total_loops: int
            - unique_fields: List[str]
            - unknown_fields: List[str]
        """
        pass
    
    @classmethod
    def extract_merge_fields(cls, content: str) -> List[str]:
        """
        Extract merge field paths from content.
        
        Args:
            content: HTML content
            
        Returns:
            List of merge field paths
        """
        pass
    
    @classmethod
    def extract_conditions(cls, content: str) -> List[str]:
        """
        Extract vitec-if conditions from content.
        
        Args:
            content: HTML content
            
        Returns:
            List of condition expressions
        """
        pass
    
    @classmethod
    def extract_loops(cls, content: str) -> List[dict]:
        """
        Extract vitec-foreach loops from content.
        
        Args:
            content: HTML content
            
        Returns:
            List of dicts with 'variable' and 'collection' keys
        """
        pass
```

---

## T4: API ENDPOINTS

### OpenAPI-Style Specification

#### Merge Fields API: `/api/merge-fields`

```yaml
paths:
  /api/merge-fields:
    get:
      summary: List merge fields
      description: Get paginated list of merge fields with optional filters
      parameters:
        - name: category
          in: query
          schema:
            type: string
          description: Filter by category
        - name: search
          in: query
          schema:
            type: string
          description: Search in path, label, description
        - name: data_type
          in: query
          schema:
            type: string
            enum: [string, number, date, boolean, array]
        - name: is_iterable
          in: query
          schema:
            type: boolean
        - name: page
          in: query
          schema:
            type: integer
            default: 1
        - name: per_page
          in: query
          schema:
            type: integer
            default: 50
            maximum: 100
      responses:
        200:
          description: Paginated list of merge fields
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MergeFieldListResponse'

    post:
      summary: Create merge field
      description: Create a new merge field
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MergeFieldCreate'
      responses:
        201:
          description: Created merge field
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MergeFieldResponse'
        409:
          description: Path already exists

  /api/merge-fields/categories:
    get:
      summary: Get categories
      description: Get list of all unique categories
      responses:
        200:
          content:
            application/json:
              schema:
                type: object
                properties:
                  categories:
                    type: array
                    items:
                      type: string

  /api/merge-fields/autocomplete:
    get:
      summary: Autocomplete search
      description: Search merge fields for autocomplete suggestions
      parameters:
        - name: q
          in: query
          required: true
          schema:
            type: string
          description: Search query
        - name: limit
          in: query
          schema:
            type: integer
            default: 10
      responses:
        200:
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/MergeFieldResponse'

  /api/merge-fields/scan:
    post:
      summary: Trigger discovery
      description: Scan all templates and discover merge fields
      parameters:
        - name: create_missing
          in: query
          schema:
            type: boolean
            default: true
          description: Create MergeField records for unknown fields
      responses:
        200:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MergeFieldDiscoveryResult'

  /api/merge-fields/{field_id}:
    get:
      summary: Get merge field
      parameters:
        - name: field_id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        200:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MergeFieldResponse'
        404:
          description: Not found

    put:
      summary: Update merge field
      parameters:
        - name: field_id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MergeFieldUpdate'
      responses:
        200:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MergeFieldResponse'

    delete:
      summary: Delete merge field
      parameters:
        - name: field_id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        204:
          description: Deleted
```

#### Code Patterns API: `/api/code-patterns`

```yaml
paths:
  /api/code-patterns:
    get:
      summary: List code patterns
      parameters:
        - name: category
          in: query
          schema:
            type: string
        - name: search
          in: query
          schema:
            type: string
        - name: page
          in: query
          schema:
            type: integer
            default: 1
        - name: per_page
          in: query
          schema:
            type: integer
            default: 20
      responses:
        200:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CodePatternListResponse'

    post:
      summary: Create code pattern
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CodePatternCreate'
      responses:
        201:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CodePatternResponse'

  /api/code-patterns/categories:
    get:
      summary: Get categories
      responses:
        200:
          content:
            application/json:
              schema:
                type: object
                properties:
                  categories:
                    type: array
                    items:
                      type: string

  /api/code-patterns/{pattern_id}:
    get:
      summary: Get code pattern
      parameters:
        - name: pattern_id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        200:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CodePatternResponse'
        404:
          description: Not found

    put:
      summary: Update code pattern
      parameters:
        - name: pattern_id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CodePatternUpdate'
      responses:
        200:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CodePatternResponse'

    delete:
      summary: Delete code pattern
      parameters:
        - name: pattern_id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        204:
          description: Deleted
```

#### Layout Partials API: `/api/layout-partials`

```yaml
paths:
  /api/layout-partials:
    get:
      summary: List layout partials
      parameters:
        - name: type
          in: query
          schema:
            type: string
            enum: [header, footer]
        - name: context
          in: query
          schema:
            type: string
            enum: [pdf, email, all]
      responses:
        200:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LayoutPartialListResponse'

    post:
      summary: Create layout partial
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/LayoutPartialCreate'
      responses:
        201:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LayoutPartialResponse'

  /api/layout-partials/default:
    get:
      summary: Get default partial
      parameters:
        - name: type
          in: query
          required: true
          schema:
            type: string
            enum: [header, footer]
        - name: context
          in: query
          schema:
            type: string
            enum: [pdf, email, all]
            default: all
      responses:
        200:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LayoutPartialResponse'
        404:
          description: No default set

  /api/layout-partials/{partial_id}:
    get:
      summary: Get layout partial
      parameters:
        - name: partial_id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        200:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LayoutPartialResponse'

    put:
      summary: Update layout partial
      parameters:
        - name: partial_id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/LayoutPartialUpdate'
      responses:
        200:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LayoutPartialResponse'

    delete:
      summary: Delete layout partial
      parameters:
        - name: partial_id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        204:
          description: Deleted
        409:
          description: Partial is in use by templates

  /api/layout-partials/{partial_id}/set-default:
    post:
      summary: Set as default
      description: Set this partial as the default for its type/context
      parameters:
        - name: partial_id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        200:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LayoutPartialSetDefaultResponse'
```

#### Template Analysis API

```yaml
paths:
  /api/templates/{template_id}/analyze:
    get:
      summary: Analyze template
      description: Analyze template for merge fields, conditions, and loops
      parameters:
        - name: template_id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      responses:
        200:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TemplateAnalysisResult'
        400:
          description: Template is not HTML
        404:
          description: Template not found
```

---

## T5: MODEL DEFINITIONS

### File: `backend/app/models/merge_field.py`

```python
"""
MergeField SQLAlchemy Model
"""

from sqlalchemy import Column, String, Text, Integer, Boolean, DateTime, Index
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
from sqlalchemy.orm import Mapped, mapped_column
from datetime import datetime
from typing import Optional
import uuid

from app.models.base import Base


class MergeField(Base):
    """
    Merge field model for the Flettekode system.
    """
    
    __tablename__ = "merge_fields"
    
    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4
    )
    
    path: Mapped[str] = mapped_column(String(200), unique=True, nullable=False)
    category: Mapped[str] = mapped_column(String(100), nullable=False)
    label: Mapped[str] = mapped_column(String(200), nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    example_value: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)
    data_type: Mapped[str] = mapped_column(String(50), default="string")
    is_iterable: Mapped[bool] = mapped_column(Boolean, default=False)
    parent_model: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)
    usage_count: Mapped[int] = mapped_column(Integer, default=0)
    
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now()
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now()
    )
    
    __table_args__ = (
        Index("idx_merge_fields_category", "category"),
        Index("idx_merge_fields_path", "path"),
        Index("idx_merge_fields_parent_model", "parent_model"),
    )
    
    def __repr__(self) -> str:
        return f"<MergeField(path='{self.path}', category='{self.category}')>"
```

### File: `backend/app/models/code_pattern.py`

```python
"""
CodePattern SQLAlchemy Model
"""

from sqlalchemy import Column, String, Text, Integer, DateTime, Index
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.sql import func
from sqlalchemy.orm import Mapped, mapped_column
from datetime import datetime
from typing import Optional, List
import uuid

from app.models.base import Base


class CodePattern(Base):
    """
    Code pattern model for reusable HTML/Vitec snippets.
    """
    
    __tablename__ = "code_patterns"
    
    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4
    )
    
    name: Mapped[str] = mapped_column(String(200), nullable=False)
    category: Mapped[str] = mapped_column(String(100), nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    html_code: Mapped[str] = mapped_column(Text, nullable=False)
    variables_used: Mapped[Optional[List[str]]] = mapped_column(
        JSONB,
        nullable=True,
        default=list
    )
    preview_thumbnail_url: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    usage_count: Mapped[int] = mapped_column(Integer, default=0)
    
    created_by: Mapped[str] = mapped_column(String(255), nullable=False)
    updated_by: Mapped[str] = mapped_column(String(255), nullable=False)
    
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now()
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now()
    )
    
    __table_args__ = (
        Index("idx_code_patterns_category", "category"),
        Index("idx_code_patterns_name", "name"),
    )
    
    def __repr__(self) -> str:
        return f"<CodePattern(name='{self.name}', category='{self.category}')>"
```

### File: `backend/app/models/layout_partial.py`

```python
"""
LayoutPartial SQLAlchemy Model
"""

from sqlalchemy import Column, String, Text, Boolean, DateTime, Index, CheckConstraint
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
from sqlalchemy.orm import Mapped, mapped_column
from datetime import datetime
from typing import Literal
import uuid

from app.models.base import Base


class LayoutPartial(Base):
    """
    Layout partial model for headers and footers.
    """
    
    __tablename__ = "layout_partials"
    
    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4
    )
    
    name: Mapped[str] = mapped_column(String(200), nullable=False)
    type: Mapped[str] = mapped_column(String(20), nullable=False)  # 'header' | 'footer'
    context: Mapped[str] = mapped_column(String(50), default='all')  # 'pdf' | 'email' | 'all'
    html_content: Mapped[str] = mapped_column(Text, nullable=False)
    is_default: Mapped[bool] = mapped_column(Boolean, default=False)
    
    created_by: Mapped[str] = mapped_column(String(255), nullable=False)
    updated_by: Mapped[str] = mapped_column(String(255), nullable=False)
    
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now()
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now()
    )
    
    __table_args__ = (
        Index("idx_layout_partials_type", "type"),
        Index("idx_layout_partials_context", "context"),
        Index("idx_layout_partials_is_default", "is_default"),
        CheckConstraint("type IN ('header', 'footer')", name="ck_layout_partial_type"),
        CheckConstraint("context IN ('pdf', 'email', 'all')", name="ck_layout_partial_context"),
    )
    
    def __repr__(self) -> str:
        return f"<LayoutPartial(name='{self.name}', type='{self.type}')>"
```

---

## ROUTER FILES

### File: `backend/app/routers/merge_fields.py`

```python
"""
Merge Fields API Routes
"""

from fastapi import APIRouter, HTTPException, Query, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional
from uuid import UUID

from app.database import get_db
from app.services.merge_field_service import MergeFieldService
from app.schemas.merge_field import (
    MergeFieldCreate,
    MergeFieldUpdate,
    MergeFieldResponse,
    MergeFieldListResponse,
    MergeFieldDiscoveryResult
)

router = APIRouter(prefix="/merge-fields", tags=["Merge Fields"])


@router.get("", response_model=MergeFieldListResponse)
async def list_merge_fields(
    db: AsyncSession = Depends(get_db),
    category: Optional[str] = Query(None),
    search: Optional[str] = Query(None),
    data_type: Optional[str] = Query(None),
    is_iterable: Optional[bool] = Query(None),
    page: int = Query(1, ge=1),
    per_page: int = Query(50, ge=1, le=100)
):
    """List all merge fields with optional filters."""
    fields, total = await MergeFieldService.get_list(
        db,
        category=category,
        search=search,
        data_type=data_type,
        is_iterable=is_iterable,
        page=page,
        per_page=per_page
    )
    
    return MergeFieldListResponse(
        merge_fields=[MergeFieldResponse.model_validate(f) for f in fields],
        total=total,
        page=page,
        per_page=per_page,
        total_pages=(total + per_page - 1) // per_page if total > 0 else 0
    )


@router.get("/categories")
async def get_categories(db: AsyncSession = Depends(get_db)):
    """Get list of all unique categories."""
    categories = await MergeFieldService.get_categories(db)
    return {"categories": categories}


@router.get("/autocomplete")
async def autocomplete(
    db: AsyncSession = Depends(get_db),
    q: str = Query(..., min_length=1),
    limit: int = Query(10, ge=1, le=50)
):
    """Search merge fields for autocomplete suggestions."""
    fields = await MergeFieldService.search_autocomplete(db, q, limit)
    return [MergeFieldResponse.model_validate(f) for f in fields]


@router.post("/scan", response_model=MergeFieldDiscoveryResult)
async def trigger_discovery(
    db: AsyncSession = Depends(get_db),
    create_missing: bool = Query(True)
):
    """Scan all templates and discover merge fields."""
    result = await MergeFieldService.discover_all(db, create_missing=create_missing)
    return MergeFieldDiscoveryResult(**result)


@router.get("/{field_id}", response_model=MergeFieldResponse)
async def get_merge_field(
    field_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Get a merge field by ID."""
    field = await MergeFieldService.get_by_id(db, field_id)
    if not field:
        raise HTTPException(status_code=404, detail="Merge field not found")
    return MergeFieldResponse.model_validate(field)


@router.post("", response_model=MergeFieldResponse, status_code=201)
async def create_merge_field(
    body: MergeFieldCreate,
    db: AsyncSession = Depends(get_db)
):
    """Create a new merge field."""
    existing = await MergeFieldService.get_by_path(db, body.path)
    if existing:
        raise HTTPException(status_code=409, detail=f"Path '{body.path}' already exists")
    
    field = await MergeFieldService.create(db, **body.model_dump())
    return MergeFieldResponse.model_validate(field)


@router.put("/{field_id}", response_model=MergeFieldResponse)
async def update_merge_field(
    field_id: UUID,
    body: MergeFieldUpdate,
    db: AsyncSession = Depends(get_db)
):
    """Update a merge field."""
    field = await MergeFieldService.get_by_id(db, field_id)
    if not field:
        raise HTTPException(status_code=404, detail="Merge field not found")
    
    field = await MergeFieldService.update(db, field, **body.model_dump(exclude_unset=True))
    return MergeFieldResponse.model_validate(field)


@router.delete("/{field_id}", status_code=204)
async def delete_merge_field(
    field_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Delete a merge field."""
    field = await MergeFieldService.get_by_id(db, field_id)
    if not field:
        raise HTTPException(status_code=404, detail="Merge field not found")
    
    await MergeFieldService.delete(db, field)
    return None
```

---

## FILE STRUCTURE ADDITIONS

```
backend/
├── app/
│   ├── models/
│   │   ├── merge_field.py        # NEW
│   │   ├── code_pattern.py       # NEW
│   │   └── layout_partial.py     # NEW
│   ├── schemas/
│   │   ├── merge_field.py        # NEW
│   │   ├── code_pattern.py       # NEW
│   │   ├── layout_partial.py     # NEW
│   │   └── template_metadata.py  # NEW
│   ├── services/
│   │   ├── merge_field_service.py       # NEW
│   │   ├── code_pattern_service.py      # NEW
│   │   ├── layout_partial_service.py    # NEW
│   │   └── template_analyzer_service.py # NEW
│   └── routers/
│       ├── merge_fields.py      # NEW
│       ├── code_patterns.py     # NEW
│       └── layout_partials.py   # NEW
└── alembic/
    └── versions/
        ├── YYYYMMDD01_add_vitec_metadata_to_templates.py
        ├── YYYYMMDD02_create_merge_fields.py
        ├── YYYYMMDD03_create_code_patterns.py
        ├── YYYYMMDD04_create_layout_partials.py
        └── YYYYMMDD05_seed_merge_fields.py
```

---

## HANDOFF TO BUILDER AGENT

### Implementation Order

1. **Models First** - Create all SQLAlchemy models in `app/models/`
2. **Migrations** - Generate Alembic migrations from models
3. **Schemas** - Create Pydantic schemas in `app/schemas/`
4. **Services** - Implement service classes with business logic
5. **Routers** - Create API routes
6. **Register Routes** - Add routers to `app/main.py`
7. **Seed Data** - Run seed migration for merge_fields
8. **Test** - Verify all endpoints work

### Test Criteria

- [ ] `GET /api/merge-fields` returns paginated list
- [ ] `POST /api/merge-fields/scan` discovers fields from templates
- [ ] `GET /api/merge-fields/autocomplete?q=sel` returns matching fields
- [ ] `GET /api/code-patterns` returns patterns
- [ ] `GET /api/layout-partials?type=header` returns headers only
- [ ] `POST /api/layout-partials/{id}/set-default` updates default flag
- [ ] `GET /api/templates/{id}/analyze` returns analysis result

---

**Next Step:** Invoke **FRONTEND ARCHITECT** agent to create `frontend_spec.md`
