---
phase: 06-entra-signature-sync
plan: 14
type: execute
wave: 3
depends_on: [06-13]
files_modified:
  - backend/app/schemas/salesscreen.py
  - backend/app/services/salesscreen_service.py
  - backend/app/routers/salesscreen.py
  - backend/app/main.py
autonomous: true
---

<objective>
Create SalesScreen backend service and API endpoints.
</objective>

<context>
Service should work with mock data initially until we have real API credentials.
API endpoints mirror the Entra sync pattern for consistency.

See: 06-13-RESEARCH-SALESSCREEN.md for expected API patterns.
</context>

<tasks>
<task type="auto">
  <name>Task 1: Create Pydantic Schemas</name>
  <files>backend/app/schemas/salesscreen.py</files>
  <action>
    Create schemas:
    ```python
    from pydantic import BaseModel
    from uuid import UUID
    
    class SalesScreenUser(BaseModel):
        """User representation in SalesScreen"""
        id: str | None = None
        email: str
        first_name: str
        last_name: str
        title: str | None = None
        phone: str | None = None
        team_id: str | None = None
        photo_url: str | None = None
    
    class SalesScreenSyncPreview(BaseModel):
        """Preview of what sync would do"""
        employee_id: UUID
        employee_name: str
        office_name: str
        salesscreen_team_id: str | None
        changes: list[dict]  # [{field, current, new}]
        can_sync: bool
        reason: str | None = None  # If can_sync=False
    
    class SalesScreenSyncRequest(BaseModel):
        """Request to sync employee(s)"""
        employee_ids: list[UUID]
        include_photo: bool = True
    
    class SalesScreenSyncResult(BaseModel):
        """Result of sync operation"""
        employee_id: UUID
        success: bool
        salesscreen_user_id: str | None = None
        error: str | None = None
    
    class SalesScreenBatchResult(BaseModel):
        """Result of batch sync"""
        total: int
        succeeded: int
        failed: int
        results: list[SalesScreenSyncResult]
    
    class SalesScreenConnectionStatus(BaseModel):
        """API connection status"""
        connected: bool
        configured: bool  # Credentials set
        error: str | None = None
    ```
  </action>
</task>

<task type="auto">
  <name>Task 2: Create SalesScreen Service</name>
  <files>backend/app/services/salesscreen_service.py</files>
  <action>
    Create service with mock implementation:
    ```python
    import httpx
    from uuid import UUID
    from sqlalchemy.ext.asyncio import AsyncSession
    from app.config import settings
    from app.models.employee import Employee
    from app.models.office import Office
    from app.schemas.salesscreen import *
    
    class SalesScreenService:
        def __init__(self, db: AsyncSession):
            self.db = db
            self.api_url = settings.SALESSCREEN_API_URL
            self.client_id = settings.SALESSCREEN_CLIENT_ID
            self.client_secret = settings.SALESSCREEN_CLIENT_SECRET
        
        async def check_connection(self) -> SalesScreenConnectionStatus:
            """Check if SalesScreen API is configured and reachable."""
            configured = bool(self.api_url and self.client_id)
            if not configured:
                return SalesScreenConnectionStatus(
                    connected=False,
                    configured=False,
                    error="SalesScreen not configured"
                )
            
            # TODO: Actual API ping when credentials available
            return SalesScreenConnectionStatus(
                connected=True,  # Mock: assume connected
                configured=True
            )
        
        async def get_sync_preview(
            self, 
            employee_id: UUID
        ) -> SalesScreenSyncPreview:
            """Preview what syncing an employee would do."""
            employee = await self._get_employee_with_office(employee_id)
            
            if not employee.office.salesscreen_enabled:
                return SalesScreenSyncPreview(
                    employee_id=employee_id,
                    employee_name=f"{employee.first_name} {employee.last_name}",
                    office_name=employee.office.name,
                    salesscreen_team_id=None,
                    changes=[],
                    can_sync=False,
                    reason="Office does not have SalesScreen enabled"
                )
            
            # TODO: Fetch current user from SalesScreen and compare
            changes = [
                {"field": "firstName", "current": None, "new": employee.first_name},
                {"field": "lastName", "current": None, "new": employee.last_name},
                {"field": "email", "current": None, "new": employee.email},
                {"field": "title", "current": None, "new": employee.title},
                {"field": "phone", "current": None, "new": employee.phone},
            ]
            
            return SalesScreenSyncPreview(
                employee_id=employee_id,
                employee_name=f"{employee.first_name} {employee.last_name}",
                office_name=employee.office.name,
                salesscreen_team_id=employee.office.salesscreen_team_id,
                changes=changes,
                can_sync=True
            )
        
        async def sync_employee(
            self,
            employee_id: UUID,
            include_photo: bool = True
        ) -> SalesScreenSyncResult:
            """Sync a single employee to SalesScreen."""
            employee = await self._get_employee_with_office(employee_id)
            
            if not employee.office.salesscreen_enabled:
                return SalesScreenSyncResult(
                    employee_id=employee_id,
                    success=False,
                    error="Office does not have SalesScreen enabled"
                )
            
            # TODO: Actual API call when credentials available
            # Mock success for now
            return SalesScreenSyncResult(
                employee_id=employee_id,
                success=True,
                salesscreen_user_id=f"mock-{employee_id}"
            )
        
        async def sync_batch(
            self,
            request: SalesScreenSyncRequest
        ) -> SalesScreenBatchResult:
            """Sync multiple employees."""
            results = []
            for emp_id in request.employee_ids:
                result = await self.sync_employee(emp_id, request.include_photo)
                results.append(result)
            
            succeeded = sum(1 for r in results if r.success)
            return SalesScreenBatchResult(
                total=len(results),
                succeeded=succeeded,
                failed=len(results) - succeeded,
                results=results
            )
        
        async def _get_employee_with_office(self, employee_id: UUID) -> Employee:
            """Get employee with office loaded."""
            from sqlalchemy import select
            from sqlalchemy.orm import selectinload
            
            stmt = (
                select(Employee)
                .where(Employee.id == employee_id)
                .options(selectinload(Employee.office))
            )
            result = await self.db.execute(stmt)
            employee = result.scalar_one_or_none()
            
            if not employee:
                raise ValueError(f"Employee {employee_id} not found")
            
            return employee
    ```
  </action>
</task>

<task type="auto">
  <name>Task 3: Create API Router</name>
  <files>backend/app/routers/salesscreen.py</files>
  <action>
    Create router:
    ```python
    from fastapi import APIRouter, Depends
    from sqlalchemy.ext.asyncio import AsyncSession
    from uuid import UUID
    
    from app.database import get_db
    from app.services.salesscreen_service import SalesScreenService
    from app.schemas.salesscreen import (
        SalesScreenConnectionStatus,
        SalesScreenSyncPreview,
        SalesScreenSyncRequest,
        SalesScreenSyncResult,
        SalesScreenBatchResult,
    )
    
    router = APIRouter(prefix="/salesscreen", tags=["salesscreen"])
    
    @router.get("/status")
    async def get_connection_status(
        db: AsyncSession = Depends(get_db)
    ) -> SalesScreenConnectionStatus:
        """Check SalesScreen API connection status."""
        service = SalesScreenService(db)
        return await service.check_connection()
    
    @router.get("/preview/{employee_id}")
    async def preview_sync(
        employee_id: UUID,
        db: AsyncSession = Depends(get_db)
    ) -> SalesScreenSyncPreview:
        """Preview what syncing an employee would do."""
        service = SalesScreenService(db)
        return await service.get_sync_preview(employee_id)
    
    @router.post("/sync/{employee_id}")
    async def sync_employee(
        employee_id: UUID,
        include_photo: bool = True,
        db: AsyncSession = Depends(get_db)
    ) -> SalesScreenSyncResult:
        """Sync a single employee to SalesScreen."""
        service = SalesScreenService(db)
        return await service.sync_employee(employee_id, include_photo)
    
    @router.post("/sync/batch")
    async def sync_batch(
        request: SalesScreenSyncRequest,
        db: AsyncSession = Depends(get_db)
    ) -> SalesScreenBatchResult:
        """Sync multiple employees to SalesScreen."""
        service = SalesScreenService(db)
        return await service.sync_batch(request)
    ```
  </action>
</task>

<task type="auto">
  <name>Task 4: Register Router</name>
  <files>backend/app/main.py</files>
  <action>
    Add router:
    ```python
    from app.routers import salesscreen
    
    app.include_router(salesscreen.router, prefix="/api")
    ```
  </action>
</task>
</tasks>

<success_criteria>
- GET /api/salesscreen/status returns connection info
- GET /api/salesscreen/preview/{id} returns sync preview
- POST /api/salesscreen/sync/{id} syncs single employee
- POST /api/salesscreen/sync/batch syncs multiple employees
- Disabled offices return can_sync=False
- Mock implementation works for testing
</success_criteria>
