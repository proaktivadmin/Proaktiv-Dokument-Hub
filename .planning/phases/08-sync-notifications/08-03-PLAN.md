---
phase: 08-sync-notifications
plan: 03
type: execute
wave: 3
depends_on: [08-02]
files_modified:
  - frontend/src/types/notification.ts
  - frontend/src/lib/api/notifications.ts
  - frontend/src/hooks/use-notifications.ts
autonomous: true
---

<objective>
Create TypeScript types, API client, and React hook for the notification system frontend.
</objective>

<context>
Read these files first:
- `.planning/phases/08-sync-notifications/HANDOVER.md` - Master context and API endpoints
- `frontend/src/types/employee.ts` - Type pattern to follow
- `frontend/src/lib/api/employees.ts` - API client pattern to follow
- `frontend/src/lib/api/config.ts` - API configuration (resolveApiUrl)
- `frontend/src/hooks/use-employees.ts` - Hook pattern to follow
</context>

<tasks>
<task type="auto">
  <name>Task 1: Create Notification Types</name>
  <files>frontend/src/types/notification.ts</files>
  <action>
    Create TypeScript interfaces:
    
    ```typescript
    export type NotificationType =
      | "employee_added"
      | "employee_removed"
      | "employee_updated"
      | "office_added"
      | "office_removed"
      | "office_updated"
      | "upn_mismatch"
      | "sync_error";
    
    export type NotificationSeverity = "info" | "warning" | "error";
    
    export type NotificationEntityType = "employee" | "office" | "sync";
    
    export interface Notification {
      id: string;
      type: NotificationType;
      entity_type: NotificationEntityType;
      entity_id: string | null;
      title: string;
      message: string;
      severity: NotificationSeverity;
      is_read: boolean;
      metadata: Record<string, unknown> | null;
      created_at: string;
    }
    
    export interface NotificationListResponse {
      items: Notification[];
      total: number;
      unread_count: number;
    }
    
    export interface UnreadCountResponse {
      count: number;
    }
    ```
  </action>
</task>

<task type="auto">
  <name>Task 2: Create Notifications API Client</name>
  <files>frontend/src/lib/api/notifications.ts</files>
  <action>
    Create API client with methods:
    
    ```typescript
    import { resolveApiUrl } from "./config";
    import type {
      Notification,
      NotificationListResponse,
      UnreadCountResponse,
    } from "@/types/notification";
    
    export const notificationsApi = {
      async list(params?: {
        skip?: number;
        limit?: number;
        unread_only?: boolean;
      }): Promise<NotificationListResponse> {
        const searchParams = new URLSearchParams();
        if (params?.skip) searchParams.set("skip", params.skip.toString());
        if (params?.limit) searchParams.set("limit", params.limit.toString());
        if (params?.unread_only) searchParams.set("unread_only", "true");
        
        const url = resolveApiUrl(`/api/notifications?${searchParams}`);
        const res = await fetch(url, { credentials: "include" });
        if (!res.ok) throw new Error("Failed to fetch notifications");
        return res.json();
      },
      
      async getUnreadCount(): Promise<UnreadCountResponse> {
        const url = resolveApiUrl("/api/notifications/unread-count");
        const res = await fetch(url, { credentials: "include" });
        if (!res.ok) throw new Error("Failed to fetch unread count");
        return res.json();
      },
      
      async markAsRead(id: string): Promise<Notification> {
        const url = resolveApiUrl(`/api/notifications/${id}/read`);
        const res = await fetch(url, {
          method: "PATCH",
          credentials: "include",
        });
        if (!res.ok) throw new Error("Failed to mark notification as read");
        return res.json();
      },
      
      async markAllAsRead(): Promise<{ count: number }> {
        const url = resolveApiUrl("/api/notifications/read-all");
        const res = await fetch(url, {
          method: "POST",
          credentials: "include",
        });
        if (!res.ok) throw new Error("Failed to mark all as read");
        return res.json();
      },
      
      async delete(id: string): Promise<void> {
        const url = resolveApiUrl(`/api/notifications/${id}`);
        const res = await fetch(url, {
          method: "DELETE",
          credentials: "include",
        });
        if (!res.ok) throw new Error("Failed to delete notification");
      },
      
      async clearAll(): Promise<{ count: number }> {
        const url = resolveApiUrl("/api/notifications/clear");
        const res = await fetch(url, {
          method: "POST",
          credentials: "include",
        });
        if (!res.ok) throw new Error("Failed to clear notifications");
        return res.json();
      },
    };
    ```
  </action>
</task>

<task type="auto">
  <name>Task 3: Create useNotifications Hook</name>
  <files>frontend/src/hooks/use-notifications.ts</files>
  <action>
    Create React hook with SWR or useState/useEffect:
    
    ```typescript
    import { useState, useEffect, useCallback } from "react";
    import { notificationsApi } from "@/lib/api/notifications";
    import type { Notification, NotificationListResponse } from "@/types/notification";
    
    interface UseNotificationsOptions {
      limit?: number;
      pollInterval?: number; // in milliseconds, 0 to disable
    }
    
    interface UseNotificationsReturn {
      notifications: Notification[];
      unreadCount: number;
      total: number;
      isLoading: boolean;
      error: Error | null;
      refresh: () => Promise<void>;
      markAsRead: (id: string) => Promise<void>;
      markAllAsRead: () => Promise<void>;
      deleteNotification: (id: string) => Promise<void>;
      clearAll: () => Promise<void>;
    }
    
    export function useNotifications(
      options: UseNotificationsOptions = {}
    ): UseNotificationsReturn {
      const { limit = 20, pollInterval = 30000 } = options;
      
      const [notifications, setNotifications] = useState<Notification[]>([]);
      const [unreadCount, setUnreadCount] = useState(0);
      const [total, setTotal] = useState(0);
      const [isLoading, setIsLoading] = useState(true);
      const [error, setError] = useState<Error | null>(null);
      
      const fetchNotifications = useCallback(async () => {
        try {
          const data = await notificationsApi.list({ limit });
          setNotifications(data.items);
          setUnreadCount(data.unread_count);
          setTotal(data.total);
          setError(null);
        } catch (err) {
          setError(err instanceof Error ? err : new Error("Unknown error"));
        } finally {
          setIsLoading(false);
        }
      }, [limit]);
      
      // Initial fetch
      useEffect(() => {
        fetchNotifications();
      }, [fetchNotifications]);
      
      // Polling
      useEffect(() => {
        if (pollInterval <= 0) return;
        
        const interval = setInterval(fetchNotifications, pollInterval);
        return () => clearInterval(interval);
      }, [pollInterval, fetchNotifications]);
      
      const markAsRead = useCallback(async (id: string) => {
        await notificationsApi.markAsRead(id);
        setNotifications(prev =>
          prev.map(n => (n.id === id ? { ...n, is_read: true } : n))
        );
        setUnreadCount(prev => Math.max(0, prev - 1));
      }, []);
      
      const markAllAsRead = useCallback(async () => {
        await notificationsApi.markAllAsRead();
        setNotifications(prev => prev.map(n => ({ ...n, is_read: true })));
        setUnreadCount(0);
      }, []);
      
      const deleteNotification = useCallback(async (id: string) => {
        const notification = notifications.find(n => n.id === id);
        await notificationsApi.delete(id);
        setNotifications(prev => prev.filter(n => n.id !== id));
        setTotal(prev => prev - 1);
        if (notification && !notification.is_read) {
          setUnreadCount(prev => Math.max(0, prev - 1));
        }
      }, [notifications]);
      
      const clearAll = useCallback(async () => {
        await notificationsApi.clearAll();
        setNotifications([]);
        setUnreadCount(0);
        setTotal(0);
      }, []);
      
      return {
        notifications,
        unreadCount,
        total,
        isLoading,
        error,
        refresh: fetchNotifications,
        markAsRead,
        markAllAsRead,
        deleteNotification,
        clearAll,
      };
    }
    ```
  </action>
</task>

<task type="auto">
  <name>Task 4: Verify TypeScript Compilation</name>
  <files>-</files>
  <action>
    Run TypeScript compiler to verify no errors:
    
    ```bash
    cd frontend
    npx tsc --noEmit
    ```
    
    Fix any type errors that appear.
  </action>
</task>
</tasks>

<success_criteria>
- notification.ts types match backend API response shape
- notificationsApi client has all 6 methods implemented
- useNotifications hook provides:
  - notifications array
  - unreadCount number
  - isLoading/error states
  - markAsRead, markAllAsRead, deleteNotification, clearAll actions
  - Polling support (configurable interval)
- TypeScript compiles without errors
- No any types used
</success_criteria>
